{"meta":{"title":"柴德Fun","subtitle":null,"description":"学习笔记，心得分享","author":"柴德Fun","url":"https://gigsider.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-31T05:47:41.254Z","updated":"2020-07-31T05:47:41.254Z","comments":true,"path":"404.html","permalink":"https://gigsider.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-07-31T05:45:59.370Z","updated":"2020-07-31T05:45:59.370Z","comments":true,"path":"about/index.html","permalink":"https://gigsider.com/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-31T05:46:24.121Z","updated":"2020-07-31T05:46:24.121Z","comments":true,"path":"tags/index.html","permalink":"https://gigsider.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-07-31T05:53:34.577Z","updated":"2020-07-31T05:53:34.577Z","comments":true,"path":"friends/index.html","permalink":"https://gigsider.com/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-07-31T05:44:56.580Z","updated":"2020-07-31T05:44:56.580Z","comments":true,"path":"categories/index.html","permalink":"https://gigsider.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MarkDown基础语法","slug":"MarkDown-First-Met","date":"2020-07-31T01:56:18.000Z","updated":"2020-07-31T06:02:45.757Z","comments":true,"path":"blogs/MarkDown-First-Met/","link":"","permalink":"https://gigsider.com/blogs/MarkDown-First-Met/","excerpt":"MarkDown 是一种轻量级标记语言。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。","text":"MarkDown 是一种轻量级标记语言。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 1、标题 12345# 一级标题名## 二级标题名### 三级标题名......###### 六级标题名 标题最多支持六级标题 2、文字 有些文字格式 MarkDown 的原生语法并不包括， 解决方案： 使用HTML的标签 使用HTML标签+CSS样式实现自己想要的字体格式 2.1 删除线使用”~~”: 1~~加上删除线的文字~~ 效果：加上删除线的文字 2.2 斜体使用”*”: 1*斜体的文字* 效果：斜体的文字 2.3 加粗使用”**”: 1**加粗的文字** 效果：加粗的文字 2.4 表格使用”|”来分隔不同的单元格，使用”-“来分隔表头和其他行，为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用”|”来标记单元格边界，在表头下方的分隔线标记中加入”:”，即可标记下方单元格内容的对齐方式： 12345| Name | Age | Sex || :--------- | :-------: | --------: || Ming | 19 | Male || Hong | 20 | Female || Gang | 18 | Male | 效果： Name Age Sex Ming 19 Male Hong 20 Female Gang 18 Male 2.5 下划线使用 HTML &lt;u&gt; 标签: 1&lt;u&gt;HTML u 标签&lt;&#x2F;u&gt; 使用 HTML 标签 + CSS 样式: 1&lt;span style&#x3D;&quot;border-bottom:2px dashed yellow;&quot;&gt;HTML 标签 + CSS 样式&lt;&#x2F;span&gt; u标签效果：HTML u 标签 HTML + CSS 效果: HTML 标签 + CSS 样式 2.6 上标、下标上标使用 HTML &lt;sup&gt; 标签: 1SUPER&lt;sup&gt;我是上标&lt;&#x2F;sup&gt; 下标使用 HTML &lt;sub&gt; 标签: 1SUB&lt;sub&gt;我是下标&lt;&#x2F;sub&gt; 上标效果：SUPER我是上标 下标效果：SUB我是下标 3、引用 使用”&gt;”: 1234&gt;朝辞白帝彩云间&gt;&gt;千里江陵一日还&gt;&gt;&gt;两岸猿声啼不住&gt;&gt;&gt;&gt;轻舟已过万重山 效果： 朝辞白帝彩云间 千里江陵一日还 两岸猿声啼不住 轻舟已过万重山 4、列表 4.1 有序列表使用”数字. “: 1231. 注意&quot;.&quot;后要有空格2. 列表3. 有序列表 效果： 注意”.”后要有空格 列表 有序列表 4.2 无序列表使用”*”或”+”或”-“: 123* 注意符号后要有空格+ 列表- 无序列表 效果： 注意符号后要有空格 列表 无序列表 5、代码 代码中的文本都会显示为原始内容。 5.1 代码块使用”```语言名称”: 123456​&#96;&#96;&#96;c++int main()&#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; return 0;&#125; 效果： 12345int main()&#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; return 0;&#125; 5.2 行内代码使用”``“: 1&#96;System.out.println(&quot;Hello world!&quot;)&#96; 效果：System.out.println(&quot;Hello world!&quot;) 6、分割线 使用”—“或”___”或”***”（符号数大于三个即可）: 123******----------_____ 效果： 7、跳转 使用”[现实的文本](跳转的链接)“: 1[我的博客](https:&#x2F;&#x2F;www.gigsider-fun.com) 使用”&lt;跳转的链接&gt;”: 1&lt;https:&#x2F;&#x2F;www.gigsider-fun.com&gt; []()效果：我的博客 &lt;&gt;效果：https://www.gigsider-fun.com 8、图片 使用”![图片的描述](图片的地址)“: 1![测试图片](MarkDown-First-Met&#x2F;test.png) 效果： 参考视频资料：https://www.bilibili.com/video/av87982836?t=336","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/categories/MarkDown/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/tags/MarkDown/"}]},{"title":"Java NIO","slug":"Java-NIO","date":"2020-07-31T01:55:48.000Z","updated":"2020-07-31T08:49:48.247Z","comments":true,"path":"blogs/Java-NIO/","link":"","permalink":"https://gigsider.com/blogs/Java-NIO/","excerpt":"​","text":"​ 1、NIO概念1.1 Unix定义了五种 I/O 模型 阻塞 I/O 非阻塞 I/O I/O 复用 信号驱动 I/O 异步 I/O 1.1.1 阻塞（Block）和非阻塞（NonBlock）阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式：阻塞：需要等待缓冲区中的数据准备好过后才处理其他的事情，否則一直等待在那里。非阻塞：进程访问数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。 1.1.2 同步与异步一个进程的IO调用步骤大致如下： 1、进程向操作系统请求数据 2、操作系统把外部数据加载到内核的缓冲区中 3、操作系统把内核的缓冲区拷贝到进程的缓冲区 4、进程获得数据完成自己的功能 当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO Java中IO分为：BIO （Blocking IO）NIO （Non-blocking IO/New IO）AIO （Asynchronous IO/NIO2） 1.2 NIO模型图 2、 NIO与传统IO的区别 IO NIO 面向流 面向缓冲 阻塞IO 非阻塞IO 无 selector 2.1 面向流与缓冲​ IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性 2.2 阻塞与非阻塞​ Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 2.3 选择器（Selector）​ Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 3、NIO构成组件Java NIO Channel通道和流非常相似，主要有以下几点区别：a.通道可以读也可以写，多功能高速通道，流一般来说是单向的（只能读或者写,如输入流与输出流）；b.通道可以异步读写；c.通道总是基于缓冲区Buffer来读写；正如上面提到的，我们可以从通道中读取数据，写入到buffer，也可以中buffer内读数据，写入到通道中；下面有个示意图： Channel的实现： FileChannel DatagramChannel SocketChannel ServerSocketChannel FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel. Buffer用于和Channel交互。我们从channel中读取数据到buffers里，从buffer把数据写入到channel，Buffer本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。 3.1 Buffer基本用法利用Buffer读写数据，通常遵循四个步骤： 把数据写入buffer； 调用flip； 从Buffer中读取数据； 调用buffer.clear()或者buffer.compact() 当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()或compact()方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。 Buffer有三个属性:容量，位置，上限（capacity, position , limit）buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。 3.2 Java NIO Selector​ Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。因此此可以实现单线程管理多个channels，也就是可以管理多个网络连接。 1.创建 要使用必须先创建一个： 创建一个selector可以通过selector.open()方法 2.注册 如果要监测channel,必须先把channel注册到Selector上，这个操作使用channel.register(), 3.监测 我们关注的channel状态，有四种基础类型可供监听：（观察客人发来的需求） Connect, Accept, Read ,Write 通过selectedKeys()，可以获取所有channel的相关信息，包括channel本身，以及channel的状态等信息，知道了channel的状态，我们就可以对channel进行相应的操作。 4、基于NIO实现的多人聊天4.1 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class NIOSelectorDemo &#123; public static void main(String[] args) throws IOException &#123; //创建ServerSocketChannel ServerSocketChannel server = ServerSocketChannel.open(); //绑定9090端口 server.bind(new InetSocketAddress(9090)); //设置为非阻塞 server.configureBlocking(false); //创建Selector Selector selector = Selector.open(); //当serversocket有连接请求时，监控这个事件 server.register(selector, SelectionKey.OP_ACCEPT); //创建SocketChannel的ArrayList用于管理客户端与服务端的连接 ArrayList&lt;SocketChannel&gt; clients = new ArrayList&lt;SocketChannel&gt;(); while(true) &#123; //阻塞，当至少有一个channel上有事件发生时，返回 //selector.select()返回了，意味着channel发生可处理事件 selector.select(); //获得可处理的事件selectionKeys（包含目标channel） Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = keys.iterator(); while( it.hasNext() ) &#123; SelectionKey key = it.next(); it.remove(); //表示可接收请求 if(key.isAcceptable()) &#123; ServerSocketChannel socket = (ServerSocketChannel)key.channel(); //接收到客户端请求时生成SocketChannel对象，用于和客户的数据传输 SocketChannel client = socket.accept(); //设置为非阻塞 client.configureBlocking(false); //注册进Selector client.register(selector, SelectionKey.OP_READ); //向客户端发送消息“hello” ByteBuffer buf = ByteBuffer.wrap(&quot;hello&quot;.getBytes()); client.write(buf); //将新客户端添加到客户列表里 clients.add(client); &#125; else if(key.isReadable()) &#123; SocketChannel client = (SocketChannel)key.channel(); //接收来自客户端的数据，组装成msg ByteBuffer buf = ByteBuffer.allocate(1024); client.read(buf); buf.flip(); String msg = client.getRemoteAddress()+&quot;==&gt;&quot;+new String(buf.array(),0,buf.limit()); //将msg发送给所有客户端 buf.clear(); buf.put(msg.getBytes()); buf.flip(); for(int i = 0; i &lt; clients.size(); i++) &#123; SocketChannel c = clients.get(i); c.write(buf); buf.rewind(); &#125; &#125; &#125; &#125; &#125;&#125; 4.2 客户端4.2.1 读线程1234567891011121314151617181920212223242526272829303132333435class ReadThread implements Runnable&#123; private SocketChannel socket = null; public ReadThread(SocketChannel socket) &#123; // TODO Auto-generated constructor stub this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub ByteBuffer buffer = ByteBuffer.allocate(1024); while(true) &#123; try &#123; int ret = socket.read(buffer); if(ret == -1) break; buffer.flip(); System.out.println(new String(buffer.array(),0,buffer.limit())); buffer.clear(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125; 4.2.2 写线程12345678910111213141516171819202122232425262728293031323334class WriteThread implements Runnable&#123; private SocketChannel socket = null; public WriteThread(SocketChannel socket) &#123; // TODO Auto-generated constructor stub this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub ByteBuffer buffer = ByteBuffer.allocate(1024); String msg = &quot;&quot;; Scanner scanner = new Scanner(System.in); while(true) &#123; msg = scanner.nextLine(); buffer.clear(); buffer.put(msg.getBytes()); buffer.flip(); try &#123; socket.write(buffer); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Java网络编程","slug":"Java-Web","date":"2020-07-21T11:03:17.000Z","updated":"2020-08-01T10:26:47.623Z","comments":true,"path":"blogs/Java-Web/","link":"","permalink":"https://gigsider.com/blogs/Java-Web/","excerpt":"​ Java语言作为最流行的网络编程语言，提供了强大的网络编程功能。 ​ 使用Java语言可以编写底层的网络通信程序，这是通过java.net包中提供的InetAddress类、URL类、Socket类以及ServerSocket等类实现的。","text":"​ Java语言作为最流行的网络编程语言，提供了强大的网络编程功能。 ​ 使用Java语言可以编写底层的网络通信程序，这是通过java.net包中提供的InetAddress类、URL类、Socket类以及ServerSocket等类实现的。 1、网络地址类InetAddress​ 要实现网络通信，首先需要知道计算机的地址。连接到Internet上的计算机使用IP地址或域名来唯一标识，在局域网上的计算机则可以使用名称标识。在java.net包中提供了InetAddress类来表示计算机地址。​ InetAddress类没有提供构造方法，要得到一个InetAddress类对象，需要使用该类的静态方法。 eg： 12345678910111213141516171819202122public class InetAddressDemo &#123; public static void main(String[] args) &#123; try &#123; InetAddress addr = InetAddress.getLocalHost(); System.out.println(addr.getHostAddress()); System.out.println(addr.getHostName()); System.out.println(addr.getAddress().length); InetAddress addr2 = InetAddress.getByName(&quot;www.acfun.cn&quot;); System.out.println(addr2.getHostAddress()); System.out.println(addr2.getHostName()); System.out.println(addr2.getAddress().length); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 2、 URL编程2.1 URL与URL类​ URL是统一资源定位器（Uniform Resource Locator）的简写，它是WWW中网络资源定位的表示方法。​ URL的基本格式为： &lt;协议名://&gt;&lt;主机名&gt;[&lt;:端口号&gt;]&lt;/资源名&gt; 协议名表示资源使用的协议，如http、ftp、telnet、mailto或file等。 主机名为任何合法的主机域名，如www.njupt.edu.cn。 端口号是可选的，如果使用熟知端口号，则可以省略。 资源名一般用来指定远程主机上文件系统中文件的完整路径，如/index.html。 ​ URL类的实现： 12345678910111213141516171819202122232425262728293031323334static void Url1() &#123; try &#123; String s = &quot;https://www.baidu.com/&quot;; URL url = new URL(s); System.out.println(&quot;Protocol:&quot; + url.getProtocol()); //获取协议名 System.out.println(&quot;Host:&quot; + url.getHost()); //获取主机号 System.out.println(&quot;Port:&quot; + url.getPort());//获取端口号，若没有指定端口号则返回-1 System.out.println(&quot;DefaultPort:&quot; + url.getDefaultPort()); //获取默认端口号 System.out.println(&quot;File:&quot; + url.getFile()); //返回URL的文件名及路径 InputStream is = url.openStream(); InputStreamReader isr = new InputStreamReader(is,&quot;utf-8&quot;); int c = 0; while( ( c = isr.read() ) != -1) &#123; System.out.print((char)c); &#125; isr.close(); is.close(); System.out.println(&quot;finish&quot;); &#125; catch (MalformedURLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 2.2 URL的Connection类 ​ 通过URL的openStream()方法，只能获得InputStream对象。使用该对象只能从网络上读取数据。 ​ 如果希望不仅要从URL读取内容，还要向URL对象发送服务请求及参数，可以使用URLConnection类。 ​ 利用URL类提供的openConnection()方法，可以建立一个URLConnection对象。可以调用其getInputStream()方法和getOutputStream()方法得到输入流和输出流对象。 eg： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void Url2() &#123; String surl = &quot;https://www.baidu.com&quot;; try &#123; URL url = new URL(surl); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); conn.setDoOutput(true); //设置允许上传 //http请求的一些属性 conn.setRequestProperty(&quot;ContentType&quot;, &quot;text/plain&quot;); //打开连接输出流，输出数据 OutputStream os = conn.getOutputStream(); FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); int c = 0; System.out.println((char)fis.read()); while( (c=fis.read()) != -1) &#123; os.write(c); &#125; fis.close(); os.close(); //当打开输入流的时候，请求发出，并得到响应 InputStream is = conn.getInputStream(); InputStreamReader reader = new InputStreamReader(is,&quot;utf-8&quot;); c = 0; while( (c=reader.read()) != -1) &#123; System.out.print((char)c); &#125; reader.close(); is.close(); System.out.println(&quot;read finish&quot;); &#125; catch (MalformedURLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 3、Java套接字编程3.1 端口号和套接字​ 在网络上，很多应用都是采用客户/服务器（C/S）结构的。实现网络通信必须将两台机器连接起来建立一个双向通信链路，这个双向通信链路的每一端称为一个套接字（Socket）。 ​ 在Internet上使用IP地址唯一标识一台主机。​ 一台主机可能提供多种服务，仅用IP地址不能唯一标识一个服务。通常使用一个整数来标识该机器上的某个服务，这个整数就是端口号（Port）。​ 端口号是用16位整数标识，共有65536个端口号。端口号并不是机器上实际存在的物理位置，而是一种软件上的抽象。 ​ 一个TCP连接由它的两个端点来标识，而每一个端点又是由IP地址和端口号决定的。TCP连接的端点称为套接字，套接字是由IP地址和端口号构成的，如下图所示。 ​ 这里，131.6.23.13为IP地址，1500为端口号，因此套接字为131.6.23.13，1500。 3.2 套接字通信​ 运行在一台特定机器上的某个服务器（如HTTP服务器）都有一个套接字绑定到该服务器上。服务器只是等待、监听客户的连接请求。​ 在客户端，客户机需要知道服务器的主机名和端口号。为了建立连接请求，客户机试图与服务器机上的指定端口号上的服务连接，这个请求过程如下图所示。 ​ 如果正常，服务器将接受连接请求。一旦接受了请求，服务器将创建一个新的绑定到另一个端口号的套接字，然后使用该套接字与客户通信。这样，服务器可以使用原来的套接字继续监听连接请求，如图所示。 ​ 在客户端，如果连接被接受，就会创建一个套接字，客户就可以使用该套接字与服务器通信。注意，客户端的套接字并没有绑定到与服务器连接的端口号上，相反客户被指定客户程序所在机器上的一个端口号上。现在客户与服务器就可以读写套接字进行通信了。 3.3 套接字类​ 为了实现套接字通信，在java.net包中提供了两个类：Socket和ServerSocket。它们分别实现连接的客户端和服务器端的套接字。 3.3.1 Socket类Client和Server都需定义出该类的对象。创建对象时，端口号必须对应。\\ public InputStrean getInputStream() throws IOException 获得套接字绑定的数据输入流。 public OutputStream getOutputStream() throws IOException 获得套接字绑定的数据输出流。 3.3.2 ServerSocket类​ 用在服务器端。客户与服务器通信，客户向服务器提出请求，服务器监听请求，一旦监听到客户请求，服务器也要建立一个套接字。 3.3.3 客户和服务器通信的实例包括以下4个基本步骤：（1）创建套接字对象。（2）打开连接到套接字的输入输出流。（3）按照一定协议对套接字进行读写操作。（4）关闭套接字对象。 eg: 服务器代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Server &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //服务器监听在本机的8000端口 ServerSocket server = new ServerSocket(8000); System.out.println(&quot;server start..&quot;); //当接受到客户端请求后，生成一个socket，用于和客户端的数据传输 Socket socket = server.accept();//阻塞，等待客户端连接请求 System.out.println(socket.getRemoteSocketAddress());//得到Client的Socket地址 System.out.println(socket.getLocalSocketAddress());//得到Server的Socket地址 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); os.write(&quot;hello&quot;.getBytes()); os.flush(); byte[] bts = new byte[20]; //采用的是阻塞IO（若没有数据，就一直等待） int count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Client say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; &#125; is.close(); os.close(); System.out.println(&quot;server stop..&quot;); server.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 客户端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; public static void main(String[] args) &#123; try &#123; //参数是要连接的服务器地址和端口，发出连接请求，建立连接 Socket socket = new Socket(&quot;localhost&quot;,8000); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] bts = new byte[20]; int count = is.read(bts, 0, 20); System.out.println(&quot;Server say:&quot;+new String(bts,0,20)); count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Server say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; &#125; is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 3.3.4 多个客户端和服务器通信实例Server： 12345678910111213141516171819202122232425262728293031public class ServerDemo &#123; public static void main(String[] args) &#123; ServerSocket server = null; try &#123; server = new ServerSocket(9000); while( true ) &#123; Socket socket = server.accept(); //启动客户端线程，独立完成通信 new Thread(new ClientThreadDemo(socket)).start(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;server start fail..&quot;); &#125;finally &#123; try &#123; if(server !=null) server.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Client: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Client &#123; public static void main(String[] args) &#123; try &#123; //参数是要连接的服务器地址和端口，发出连接请求，建立连接 Socket socket = new Socket(&quot;localhost&quot;,9000); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] bts = new byte[20]; int count = is.read(bts, 0, 20); System.out.println(&quot;Server say:&quot;+new String(bts,0,20)); count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Server say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; &#125; is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; ClientThread: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ClientThreadDemo implements Runnable&#123; private Socket socket; public ClientThreadDemo(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub InputStream is = null; OutputStream os = null; try &#123; is = socket.getInputStream(); os = socket.getOutputStream(); os.write(&quot;hello&quot;.getBytes()); os.flush(); byte[] bts = new byte[20]; //采用的是阻塞IO（若没有数据，就一直等待） int count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Client say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(is != null) is.close(); if(os != null) os.close(); if(socket != null) socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 4、数据报通信4.1 流式通信和数据报通信​ 当编写网络程序时，有两种通信可供选择：流式通信和数据报通信。 流式通信 数据报通信 流式通信使用TCP协议，该协议是面向连接的协议。使用这种协议要求发送方和接收方都要建立套接字，一旦两个套接字建立起来，它们就可以进行双向通信，双方都可以发送和接收数据。 数据报通信使用UDP协议，该协议是一种无连接的协议。使用这种协议通信，每个数据报都是一个独立的信息单元，它包括完整的目的地址，数据报在网络上以任何可能的路径传往目的地，因此数据能否到达目的地、到达的时间以及内容的正确性都是不能保证，该协议提供的是不可靠的服务。 对于TCP，是一个面向连接的协议，在通信之前必须建立双方的连接，因此在TCP中多了一个建立连接的时间。 使用UDP时，每个数据报都给出了完整的地址信息，无需建立发送方和接收方的连接。 使用TCP就没有大小限制，一旦连接建立，就可以传输大量数据。 使用UDP传输数据时有大小限制，每个数据报必须不大于64KB。 TCP是可靠协议，确保接收方完全正确地获取发送方发送的数据。 UDP是不可靠协议，发送方发送的数据不一定以相同的次序到达接收方。 TCP使用较广泛，如TELNET远程登录、FTP文件传输都需要不定长度的数据可靠地传输，因此使用TCP协议。 UDP比较简单，需要较少的监护，因此常用于局域网分散系统中的客户/服务器应用程序。 4.2 DatagramSocket和DatagramPacket​ 用UDP编写客户/服务器程序时，无论是客户方还是服务器方，首先都要建立一个DatagramSocket对象用来接收或发送数据报，然后使用DatagramPacket类对象作为传输数据的载体。 4.2.1 数据报通信实例Server: 1234567891011121314151617181920212223242526272829303132public class UDPServerDemo &#123; public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, 1024); socket.receive(packet); //阻塞 System.out.println(&quot;Client address:&quot;+packet.getSocketAddress()); System.out.println(&quot;Client data:&quot;+new String(packet.getData(),0,packet.getLength())); String str = &quot;welcome&quot;; //从接收到的数据报取得对方的地址和端口 DatagramPacket spacket = new DatagramPacket(str.getBytes(), str.getBytes().length, packet.getAddress(), packet.getPort()); socket.send(spacket); socket.close(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Client: 12345678910111213141516171819202122232425262728293031323334public class UDPClientDemo &#123; public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(9091); String str = &quot;hello server&quot;; DatagramPacket spacket = new DatagramPacket(str.getBytes(), str.getBytes().length,InetAddress.getByName(&quot;localhost&quot;),9090); socket.send(spacket); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, 1024); socket.receive(packet); //阻塞 System.out.println(packet.getSocketAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.2.2 基于线程实现一对一通信UDPPeerDemo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class UDPReceiveThread implements Runnable&#123; private DatagramSocket socket; public UDPReceiveThread(DatagramSocket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; byte [] buffer = new byte[1024]; DatagramPacket p = null; while( true ) &#123; p = new DatagramPacket(buffer, 1024); try &#123; socket.receive(p); System.out.println(&quot;Data: &quot; + new String(p.getData(),0,p.getLength())); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125;public class UDPPeerDemo implements Runnable&#123; private DatagramSocket socket; private int port; private int rport; public UDPPeerDemo(int port,int rport) &#123; this.port = port; this.rport = rport; try &#123; socket = new DatagramSocket(port); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;套接字创建失败&quot;); &#125; &#125; @Override public void run() &#123; new Thread(new UDPReceiveThread(socket)).start(); //启动接收线程 String s = &quot;&quot;; Scanner scanner = new Scanner(System.in); DatagramPacket packet = null; while( scanner.hasNextLine() ) &#123; s = scanner.nextLine(); try &#123; packet = new DatagramPacket(s.getBytes(), s.getBytes().length, InetAddress.getByName(&quot;localhost&quot;), rport); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); continue; &#125; try &#123; socket.send(packet); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; socket.close(); &#125;&#125; UDPDemo: 123456public class UDPDemo &#123; public static void main(String[] args) &#123; new Thread(new UDPPeerDemo(9090, 9091)).start(); &#125;&#125; UDPDemo2: 123456public class UDPDemo2 &#123; public static void main(String[] args) &#123; new Thread(new UDPPeerDemo(9091, 9090)).start(); &#125;&#125; 5、小结​ 通过网络资源定位器可以指向并获取网络上丰富的资源。基于TCP的网络数据传输是一种可靠的有连接的网络数据传输。这种传输方式是目前最常用的网络数据传输方式。在基于TCP的网络程序中，服务器端与客户端的程序编写稍有些不同。​ 基于UDP的网络数据传输是一种可靠的无连接的网络数据传输。在基于UDP的网络程序设计中，服务器端与客户端的程序编写基本上是相类似的。在Java的包java.net还含有很多用于网络数据传输的类和接口，为网络编程提供了方便。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"网络编程","slug":"网络编程","permalink":"https://gigsider.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO流","slug":"Java-IO","date":"2020-07-20T08:24:58.000Z","updated":"2020-08-01T10:29:14.911Z","comments":true,"path":"blogs/Java-IO/","link":"","permalink":"https://gigsider.com/blogs/Java-IO/","excerpt":"​","text":"​ 1、流的概念1.1流（1）流是一个无结构化的数据组成的序列，流中的数据没有任何格式和含义，只是以字节或字符形式进行流入或流出。 （2）数据流的流入和流出都是以程序本身作为核心，流入是指数据从外部数据源流入到程序内部；流出是指数据从程序内部向外部流出到数据的目的地。 （3）不管是流入还是流出，其数据的流动都是通过一个管道进行的，管道两端分别连接数据源和数据目的地。 （4）流的本质就是进行数据传输，因此Java根据数据传输的特性将流抽象成各种类，以方便进行数据操作。 1.2流的分类 根据处理数据类型，可以分为字节流和字符流。 根据数据的流向可以分为输入流和输出流。 根据处理数据功能，可以分为实体流和装饰流。 实体流对数据不做任何处理，只完成基本的读写操作。 装饰流是在实体流的基础上，提供更高级的功能。 这些流都在java.io包中。 1.2.1字节流 在数据传输过程中以字节为单位进行输入和输出。 适用于传输各种类型的文件或数据。 在字节输入流中，InputStream 类是所有的输入字节流的父类，它是一个抽象类。 其子类中的ByteArrayInputStream、FileInputStream 是两种基本的实体流。 ObjectInputStream 和所有FilterInputStream 的子类都是装饰流。 在字节输出流中，OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的实体流。 ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 1.2.2字符流 在数据传输过程中以字符为单位进行输入和输出。 根据字符编码表，一个字符占用两个字节，因此字符流只适用于字符类型数据的处理。 在字符输入流中，Reader 是所有的输入字符流的父类，它是一个抽象类。 InputStreamReader 是一个连接字节流和字符流的桥梁，它使用指定的字符集读取字节并转换成字符。 其FileReader子类可以更方便地读取字符文件，也是常用的Reader流对象。 在字符输出流中，Writer是所有的输出字符流的父类，也是一个抽象类。 相对输入流的子类，输出流当中也有相应的输出子类，只是数据传输方向相反。 这些类有OutputStreamWriter及其子类FileWriter、 CharArrayWriter、StringWriter 、BufferedWriter 、PipedWriter等。 2、File类2.1文件对象与文件属性​ 文件用文件类的对象表示，有了文件对象就可以获取文件属性。 返回类型 方法名 功能 File(String filename) 在当前路径下，创建一个名字为filename的文件 | | File(String path,String filename) | 在给定的path路径下，创建一个名字为filename的文件 || String | getName() | 获取此文件（目录）的名称 || String | getPath() | 获取路径名字符串 || long | length() | 获取文件的长度。如果表示目录，则返回值不确定 || boolean | canRead() | 判断文件是否可读 || String | getAbsolutePath() | 获取路径名字符串 || boolean | canWrite() | 判断文件是否可写 || boolean | canExecute() | 判断文件是否执行 || boolean | exists() | 判断文件（目录）是否存在 || boolean | isFile() | 判断文件是否是一个标准文件 || boolean | isDirectory() | 判断文件是否是一个目录 || boolean | isHidden() | 判断文件是否是一个隐藏文件 || long | lastModified() | 判断文件最后一次被修改的时间 | 2.2目录​ Java把目录作为一种特殊的文件进行处理，它除了具备文件的基本属性如文件名、所在路径等信息以外，同时也提供了专用于目录的一些操作方法。 返回类型 方法名 功能 boolean mkdir() 创建一个目录，并返回创建结果。成功返回true，失败（目录已存在）返回false boolean mkdirs() 创建一个包括父目录在内的目录。创建所有目录成功返回true，如果失败返回false，但要注意的是有可能部分目录已创建成功 String[] list() 获取目录下字符串表示形式的文件名和目录名 String[] list(FilenameFilter filter) 获取满足指定过滤器条件的字符串表示形式的文件名和目录名 File[] listFiles() 获取目录下文件类型表示形式的文件名和目录名 File[] listFiles(FileFilter filter) 获取满足指定过滤器文件条件的文件表示形式的文件名和目录名 File[] listFiles(FilenameFliter fliter) 获取满足指定过滤器路径和文件条件的文件表示形式的文件名和目录名 2.3文件的操作 创建文件File类的方法： public boolean createNewFile() File file = new File(“D:\\\\”,”hello.txt”) file.createNewFile(); 删除文件File类中的方法: file.delete() 运行可执行文件 首先利用Runtime类的静态方法创建一个Runtime对象: Runtime ec = Runtime.getRuntime(); 然后用ec调用方法： Process exec(String command); 2.4 Scanner类与文件​ 利用Scanner类的对象还可以从文件中读取数据: Scanner input=new Scanner(文件类对象) ​ 创建的Scanner类的对象使用read()方法即可从文件中读数据。 ​ 读数据时默认以空格作为数据的分隔标记。 3、字节流和字符流3.1字节流​ 抽象类InputStream和抽象类OutputStream是所有字节流类的根类，其他字节流类都继承自这两个类。 3.1.1 字节输入流InputStream​ 字节输入流的作用是从数据输入源（例如从磁盘、网络等）获取字节数据到应用程序（内存）中。 返回类型 方法名 功能 int read() 从输入流中读取下一个字节，返回读入的字节数据；如果读到末尾，返回-1 int read(byte b[]) 从输入流中读取一定数量的字节保存到字节数组中，并返回实际读取的字节数 | int | read(byte b[],int off,int len) | 从输入流中读取最多len个字节，保存到数组b中从off开始的位置，并返回实际读入的字节数；如果off+len 大于b.length，或者off 和len中有一个是负数，那么会抛出IndexOutOfBoundsException异常 || long | skip(long n) | 从输入流中跳过并丢弃n个字节，并返回实际跳过的字节数 || void | close() | 关闭输入流，释放资源。对流的读取完毕后调用该方法以释放资源 || int | available() | 返回此输入流可以读取（或跳过）的估计字节数 || void | mark(int readlimit) | 在输入流中标记当前的位置。参数readlimit为标记失效前最多读取的字节数。如果读取的字节数超出此范围则标记失效 || void | reset() | 将输入流重新定位到最后一次调用 mark 方法时的位置 || boolean | markSupported() | 测试此输入流是否支持 mark 和 reset 方法。只有带缓存的输入流支持标记功能 | 3.1.2 文件字节输入流类FileInputStream​ 在进行字节输入流操作时，经常使用的是InputStream类的子类FileInputStream，实现简单的文件数据读取。 ​ FileInputStream类的常用构造方法： public FileInputStream(File file) throws FileNotFoundException public FileInputStream(String name) throws FileNotFoundException ​ 通过给定的File对象和文件创建文件字节输入流对象。 ​ 在创建输入流时，如果文件不存在或出现其他问题，会抛出FileNotFoundException异常，所以要注意捕获。 字节输入流读数据步骤： 设定输入流的数据源 创建指向这个数据源的输入流 从输入流中读取数据 关闭输入流 3.1.3 字节输出流OutputStream​ 字节输出流的作用是将字节数据从应用程序（内存）中传送到输出目的地，如外部设备、网络等。 ​ 字节输出流OutputStream的常用方法。 返回类型 方法名 功能 void write(int b) 将整数b的低8位写到输出流 void write(byte b[]) 将字节数组中数据写到输出流 | void | write(byte b[ ],int off,int len) | 从字节数组b的off处写len个字节数据到输出流 || void | flush() | 强制将输出流保存在缓冲区中的数据写到输出流 || void | close() | 关闭输出流，释放资源 | 3.1.4 文件字节输出流类FileOutputStream​ 在进行字节输出流操作时，经常使用的是OutputStream类的子类FileOutputStream，用于将数据写入File或其他的输出流。 ​ FileOutputStream类的常用构造方法： public FileOutputStream(File file) throws IOException public FileOutnputStream(String name) throws IOException public FileOutputStream(File file, boolean append) throws IOException public FileOutputStream(String name, boolean append) throws IOException 字节输出流写数据步骤： 设定输出流的目的地 创建指向这目的地输出 向输出流中写入数据 关闭输出流 ​ 在完成写操作过程中，系统会将数据暂存到缓冲区中，缓冲区存满后再一次性写入到输出流中。 ​ 执行close()方法时，不管缓冲区是否已满，都会把其中的数据写到输出流。 3.2 字符流​ 字符流通常用于文本文件的传输。 ​ 抽象类Reader和抽象类Writer是所有字符流类的根类，其他字符流类都继承自这两个类。 ​ 其中一些子类还在传输过程中对数据做了进一步处理以方便用户的使用。 3.2.1 字符输入流Reader​ 字符输入流Reader是所有字符输入流类的父类，实现从数据源读入字符数据。常用方法有： 返回类型 方法名 功能 int read() 从输入流读取单个字符 int read(char[] cbuf) 从输入流读取字符保存到数组cbuf中，返回读取的字符数，如果已到达流的末尾，则返回 -1 int read(char[] cbuf,int off,int len) 从输入流读取最多len个字符保存到字符数组cbuf中，存放的起始位置在off处。返回：读取的字符数，如果已到达流的末尾，则返回 -1 | long | skip(long n) | 跳过n个字符。返回：实际跳过的字符数 || void | mark(int readAheadLimit) | 标记流中的当前位置 || void | reset() | 重置该流 || boolean | markSupported() | 判断此流是否支持 mark() 操作 || void | close() | 关闭该流，释放资源 | 3.2.2 文件字符输入流FileReader​ 进行字符输入流操作时，经常使用的是Reader类的子类FileReader，用于从输入流读取数据。 ​ FileReader类的常用构造方法： public FileReader(File file) throws FileNotFoundException public FileReader(String name) throws FileNotFoundException ​ 通过给定的File对象或文件名创建字符输入流。 ​ 在创建输入流时，如果文件不存在或出现其他问题，会抛出FileNotFoundException异常。 3.2.3 字符输出流Writer 返回类型 方法名 功能 void write(int c) 将整数c的低16位写到输出流 void write(char[] cbuf) 将字符数组中数据写到输出流 void write(cbuf[ ],int off,int len) 从字符数组cbuf的off处开始取len个字符写到输出流 void write(String str) 将字符串写到输出流 void write(String str,int off,int len) 从字符串str的off处开始取len个字符数据写到输出流 void flush() 强制将输出流保存在缓冲区中的数据写到输出 void close() 关闭输出流，释放资源 3.2.4 文件字符输出流FileWriter类​ FileWriter类和字节流FileOutputStream类相对应，实现字符的输出操作，实现方法也基本相同。FileWriter类的常用构造方法： public FileWriter(File file) throws IOException public FileWriter(String name) throws IOException public FileWriter(File file, boolean append) throws IOException public FileWriter(String name, boolean append) throws IOException ​ 如果第二个参数为 true，则将字符写入文件末尾处，而不是写入文件开始处。 ​ 如果文件不存在或出现其他问题，会抛出IOException异常。 4、数据流​ 数据流是Java提供的一种装饰类流。 ​ 建立在实体流基础上，让程序不需考虑数据所占字节个数的情况下就能够正确地完成读写操作。 ​ DataInputStream类和DataOutputStream类分别为数据输入流类和数据输出流类。 4.1 数据输入流​ 数据输入流DataInputStream类允许程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。 ​ DataInputStream类的常用方法： 返回类型 方法名 功能 DataInputStream(InputStream in) 使用指定的实体流 InputStream 创建一个DataInputStream boolean readBoolean() 读取一个布尔值 byte readByte() 读取一个字节 char readChar() 读取一个字符 long readLong() 读取一个长整型数 int readInt() 读取一个整数 short readShort() 读取一个短整型数 float readFloat() 读取一个Float数 double readDouble() 读取一个Double数 String readUTF() 读取一个UTF字符串 int skipBytes(int n) 跳过并丢弃n个字节，返回实际跳过的字节数 4.2 数据输出流​ 数据输出流DataOutputStream类允许程序以适当方式将基本Java数据类型写入输出流中。DataOutputStream类的常用方法： 返回类型 方法名 功能 DataOuputStream (OutputStream out) 创建一个新的数据输出流，将数据写入指定基础输出流 void writeBoolean(Boolean v) 将一个布尔值写出到输出流 void writeByte(int v) 将一个字节写出到输出流 void writeBytes(String s) 将字符串按字节（每个字符的高八位丢弃）顺序写出到输出流中 void writeChar(int c) 将一个 char 值以2字节值形式写入输出流中，先写入高字节 void writeChars(String s) 将字符串按字符顺序写出到输出流 void writeLong(long v) 将一个长整型数写出到输出流 void writeInt(int v) 将一个整数写出到输出流 void writeShort(int v) 将一个短整型数写出到输出流 void writeFloat(float v) 将一个Float数写出到输出流 void writeDouble(double v) 将一个Double数写出到输出流 void writeUTF(String s) 将一个字符串用UTF-8编码形式写出到输出流 int size() 返回写到数据输出流中的字节数 void flush() 清空输出流，使所有缓冲中的字节被写出到流中 5、缓冲流​ 缓冲流是在实体I/O流基础上增加一个缓冲区，应用程序和I/O设备之间的数据传输都要经过缓冲区来进行。 ​ 缓冲流分为缓冲输入流和缓冲输出流。 ​ 缓冲输入流是将从输入流读入的字节/字符数据先存在缓冲区中，应用程序从缓冲区而不是从输入流读取数据； ​ 缓冲输出流是在进行数据输出时先把数据存在缓冲区中，当缓冲区满时再一次性地写到输出流中。 ​ 使用缓冲流可以减少应用程序与I/O设备之间的访问次数，提高传输效率； ​ 可以对缓冲区中的数据进行按需访问和预处理，增加访问的灵活性。 5.1 缓冲输入流​ 包括字节缓冲输入流BufferedInputStream类和字符缓冲输入流BufferedReader类。 5.1.1 字节缓冲输入流BufferedInputStream类​ 先通过实体输入流（例如FileInputStream类）对象逐一读取字节数据并存入缓冲区，应用程序则从缓冲区中读取数据。​ 构造方法： public BufferedInputStream(InputStream in) public BufferedInputStream(InputStream in,int size) ​ size:指定缓冲区的大小。 ​ BufferedInputStream类继承自InputStream，所以该类的方法与InputStream类的方法相同。 5.1.2 字符缓冲输入流BufferedReader类​ 与字节缓冲输入流BufferedInputStream类在功能和实现上基本相同。它只适用于字符读入。 ​ 构造方法： public BufferedReader(Reader in) public BufferedReader(Reader in,int sz) ​ BufferedReader类继承自Reader，所以该类的方法与Reader类的方法相同。 ​ 新增按行读取的方法：String readLine() ​ 该方法返回值为该行不包含结束符的字符串内容，如果已到达流末尾，则返回 null。 5.2 缓冲输出流​ 缓冲输出流包括字节缓冲输出流BufferedOutputStream类和字符缓冲输出流BufferedWriter类。 5.2.1 字节缓冲输出流BufferedOutputStream类​ 完成输出操作时，先将字节数据写入缓冲区，当缓冲区满时，再把缓冲区中的所有数据一次性写到底层输出流中。 ​ 构造方法： public BufferedOutputStream(OutputStream out)public BufferedOutputStream(OutputStream out,int size) ​ BufferedOutputStream类继承自OutputStream，所以该类的方法与OutputStream类的方法相同。 5.2.2 字符缓冲输出流BufferedWriter类​ 与字节缓冲输出流BufferedOutputStream类在功能和实现上是相同的。只适用于字符输出。 ​ BufferedWriter类的构造方法： public BufferedWriter(Writer out)public BufferedWriterr(Writer out,int sz) ​ BufferedWriter类继承自Writer，所以该类的方法与Writer类的方法相同。 ​ 新增写行分隔符的方法：String newLine()行分隔符字符串由系统属性 line.separator 定义。 6、 随机流​ 随机流RandomAccessFile类创建的对象既可以作为输入流，也可以作为输出流，因此建立一个随机流就可以完成读写操作。 ​ RandomAccessFile类是java.lang.Object根类的子类。 ​ RandomAccessFile类的实例对象支持对随机访问文件的读取和写入。 ​ 随机流可以用于多线程下载或多个线程同时写数据到文件，为快速完成访问提供了便利。 6.1 RandomAccessFile类 返回类型 方法名 功能 RandomAccessFile(String name, String mode) 参数name为待访问的文件名，file待访问的文件。参数mode为读写模式，常用的值有：“r”以只读方式打开文件，如果进行写操作会产生异常；“rw”：以读写方式打开文件，如果文件不存在，则创建 RandomAccessFile(File file, String mode) 同上 int read() 从文件中读取一个数据字节并以整数形式返回此字节 int read(byte[] b) 从文件中读取最多b.length 个数据字节到b数组中，并返回实际读取的字节数 int read(byte[] b, int off, int len) 从文件中读取len个字节数据到b数组中。off为字节在数组中存放的地址 XXX readXXX() 从文件中读取一个XXX类型数据，XXX包括：boolean，byte，char，short，int，lang，float，double void write(int b) 写入指定的字节 void write(byte[] b) 写入字节数组内容到文件 | void | writeXXX(XXX v) | 写入指定类型数据到文件，XXX包括：boolean，byte，char，short，int，lang，float，double || void | writeChars(String s) | 写入字符串到文件 || void | writeUTF(String s) | 按UTF-8编码形式将字符串写入到文件 || long | getFilePointer() | 获取文件的当前偏移量 || void | seek(long pos) | 设置文件的指针偏移量 || long | length() | 获取文件的长度 || void | setLength(long newLength) | 设置此文件的长度。 如果 length 方法返回的文件的现有长度大于 newLength 参数，则该文件将被截短。超过则加大文件，多出部分没有内容 || int | skipBytes(int n) | 跳过输入的 n 个字节并丢弃跳过的字节 || void | close() | 关闭文件流，释放资源 | ​ 由于编码格式不同当进行字符串读取的时候，有时会出现“乱码”的现象。 ​ 对字符串重新进行编码可以解决乱码问题： 先读字符串：String str = in.readLine(); 再将字符串恢复成标准字节数组：byte [] b=str.getBytes(“iso-8859-1”); 最后将字节数组按当前机器的默认编码重新转化为字符串：String result=new String(b); 显式地指明编码类型，可以直接给出编码类型：String result=new String(b,”GB2312”); 7、对象流​ 对象流是在实体流基础上，通过对对象数据的处理和变换，实现对象的永久保存和读取。 ​ ObjectInputStream和ObjectOutputStream分别是对象输入流类和对象输出流类，它们也是InputStream和OutputStream类的子类。 ​ 通过对象输出流，可以把对象写入到文件或进行网络传输。 ​ 对象输入流类可以从文件或网络上，把读取的数据还原成对象。 ​ 要想实现对象的传输，待传输的对象要先进行序列化处理，才能保证对象能准确地保存和读取。 7.1 对象的序列化​ 对象的序列化是指把对象转换成字节序列的过程，而把字节序列恢复为对象的过程称为对象的反序列化。 ​ 一个类如果实现了java.io.Serializable接口，这个类的实例（对象）就是一个序列化的对象。 ​ Serializable接口中没有方法。实现了该接口的对象进行输出时，JVM将按照一定的格式（序列化信息）转换成字节进行传输和存储到目的地。 ​ 对象输入流从文件或网络上读取对象时，会先读取对象的序列化信息，并根据这一信息创建对象。 7.2 对象输入流与对象输出流7.2.1 对象输入流ObjectInputStream类​ 实现对象的输入操作。构造方法： public ObjectInputStream(InputStream in) ​ 类中的方法：Object readObject()从ObjectInputStream流中读取对象。 7.2.2 对象输出流ObjectOutputStream类​ 实现对象的输出操作。构造方法： ​ public ObjectOutputStream(OutputStream out) ​ 类中的方法：void writeObject(Object o)将指定对象o写入ObjectOutputStream流中。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"IO流","slug":"IO流","permalink":"https://gigsider.com/tags/IO%E6%B5%81/"}]}],"categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/categories/MarkDown/"},{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/tags/MarkDown/"},{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"网络编程","slug":"网络编程","permalink":"https://gigsider.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"IO流","slug":"IO流","permalink":"https://gigsider.com/tags/IO%E6%B5%81/"}]}