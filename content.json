{"meta":{"title":"柴德Fun","subtitle":null,"description":"学习笔记，心得分享","author":"柴德Fun","url":"https://gigsider.com","root":"/"},"pages":[{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2020-08-21T10:37:50.543Z","comments":true,"path":"link/index.html","permalink":"https://gigsider.com/link/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-08-21T06:22:48.000Z","updated":"2020-08-21T10:46:43.072Z","comments":true,"path":"about/index.html","permalink":"https://gigsider.com/about/index.html","excerpt":"","text":"关于作者 南京邮电大学，软件工程专业，大四学生。 关于本站 本站内容以技术积累为主，但不排除写一些其他方面的内容。本站使用的主题为Butterfly。"},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2020-08-21T10:37:58.626Z","comments":true,"path":"tags/index.html","permalink":"https://gigsider.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2020-08-21T10:37:43.783Z","comments":true,"path":"categories/index.html","permalink":"https://gigsider.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"AOP技术(2)","slug":"AOP_2","date":"2020-08-01T08:30:08.000Z","updated":"2020-08-15T11:13:22.457Z","comments":true,"path":"blogs/AOP_2/","link":"","permalink":"https://gigsider.com/blogs/AOP_2/","excerpt":"​ 摘要：通过自己的spring内核实现AOP、实现AOP的两种技术","text":"​ 摘要：通过自己的spring内核实现AOP、实现AOP的两种技术 ​ 1 通过自己的spring内核实现AOP配置文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans&gt; &lt;bean name=&quot;before&quot; class=&quot;com.hugeyurt.base.test.DemoBefore&quot; /&gt; &lt;bean name=&quot;after&quot; class=&quot;com.hugeyurt.base.test.DemoAfterMethod&quot;/&gt; &lt;bean name=&quot;aobj&quot; class=&quot;com.hugeyurt.base.test.A&quot;/&gt; &lt;bean name=&quot;proxy&quot; class=&quot;com.hugeyurt.base.test.ProxyHelloTwo&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;aobj&quot;/&gt; &lt;property name=&quot;before&quot; ref=&quot;before&quot;/&gt; &lt;property name=&quot;after&quot; ref=&quot;after&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 通过解析这个配置文件，可以得到两个切片的对象，被代理的对象。然后使用接口对象去引用该中间代理类生成的对象，即可实现AOP功能。 实现接口的类A： 1234567891011121314public class A implements IHello &#123; @Override public void sayHello(String str) &#123; // TODO Auto-generated method stub System.out.println(&quot;my is A object...&quot;+str); &#125; @Override public void sayBye() &#123; // TODO Auto-generated method stub System.out.println(&quot;my is A object...bye byte&quot;); &#125;&#125; 增加切片操作的类： 12345678910public class DemoAfterMethod implements AfterMethod&#123; @Override public void say() &#123; // TODO Auto-generated method stub System.out.println(&quot;just a test aftermethod&quot;); &#125;&#125; 中间代理类： 123456789101112131415161718192021222324252627282930313233343536public class ProxyHelloTwo implements IHello&#123; private IHello target; private BeforeMethod before; private AfterMethod after; public ProxyHelloTwo() &#123; &#125; public ProxyHelloTwo(IHello target,BeforeMethod before, AfterMethod after) &#123; this.target=target; this.before=before; this.after=after; &#125; @Override public void sayHello(String str) &#123; // TODO Auto-generated method stub if(this.before!=null) before.say(); target.sayHello(str);// 调用被代理对象的方法 if(this.after!=null) after.say(); &#125; @Override public void sayBye() &#123; target.sayBye(); &#125;&#125; main函数： 12345678910public class ProxyBySelfSpring &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub IHello target=(IHello)SpringCore.getBean(&quot;proxy&quot;); target.sayHello(&quot;I like china!&quot;); target.sayBye(); &#125;&#125; 2 实现AOP的两种技术2.1 三种切片类型 AfterAdvice 12345678910public class AfterAdviceDemo implements AfterReturningAdvice&#123; @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(&quot;after advice demo.....&quot;); &#125; &#125; BeforeAdvice 123456789101112131415public class DemoBeforeAdvice implements MethodBeforeAdvice&#123; @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; //if(method.getName().equals(&quot;printName&quot;)) return ; System.out.println(&quot;**********before****************&quot;); System.out.println(method.getName()); System.out.println(target); ///method.invoke(target, args); System.out.println(&quot;-------------------------------&quot;); System.out.println(&quot;BeforeMethod : Before method finished!&quot;); &#125;&#125; RoundAdvice 1234567891011public class RoundAdviceDemo implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation arg0) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(&quot;round demo....&quot;); Object object= arg0.proceed();// 调用代理对象的方法 System.out.println(&quot;after round demo....&quot;); return object; &#125;&#125; 2.2 JDK动态代理技术​ 应用场景：实现了接口的类。 ​ 如何实现：定义Proxy类实现接口，重写接口的方法，从而增加切片。 实现了接口的类： 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class ServiceDemo implements IAopDemo&#123; private String name=&quot;hzhqian&quot;; private String url; public void setName(String name) &#123; this.name = name; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public void printName() &#123; System.out.println(&quot;name : &quot; + this.name); &#125; public void printURL() &#123; System.out.println(&quot;company : &quot; + this.url); &#125; public void printThrowException() &#123; throw new IllegalArgumentException(); &#125; @Override public void printA() &#123; // TODO Auto-generated method stub System.out.println(&quot;interface A demo...&quot;); &#125; @Override public void PrintB() &#123; // TODO Auto-generated method stub System.out.println(&quot;interface B demo...&quot;); &#125;&#125; main函数： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; ApplicationContext appContext = new ClassPathXmlApplicationContext( new String[] &#123; &quot;beans.xml&quot; &#125;); IAopDemo demo =(IAopDemo) appContext.getBean(&quot;serviceProxy&quot;); System.out.println(demo.getClass().getName()); System.out.println(demo instanceof IAopDemo); System.out.println(demo.getClass().getSuperclass().getName()); System.out.println(&quot;------------------------------------&quot;); demo.printA(); demo.PrintB(); /* System.out.println(&quot;subject中的属性有：&quot;); Field[] field=demo.getClass().getDeclaredFields(); try&#123; for(Field f:field) &#123; System.out.print(f.getName()+&quot;, &quot;+f.getType()+&quot; # &quot;); f.setAccessible(true); System.out.println(f.get(demo)+&quot; #&quot;+f.getModifiers()); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; */&#125; xml配置文件： 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;bean id=&quot;demoService&quot; class=&quot;com.hugeyurt.springAOP.ServiceDemo&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;hugeyurt&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;hugeyurt.com&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;beforeDemo&quot; class=&quot;com.hugeyurt.springAOP.DemoBeforeAdvice&quot; /&gt; &lt;bean id=&quot;afterDemo&quot; class=&quot;com.hugeyurt.springAOP.AfterAdviceDemo&quot; /&gt; &lt;bean id=&quot;roundDemo&quot; class=&quot;com.hugeyurt.springAOP.RoundAdviceDemo&quot; /&gt; &lt;bean id=&quot;serviceProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;demoService&quot; /&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;!--&lt;value&gt;beforeDemo&lt;/value&gt; --&gt; &lt;!-- &lt;value&gt;afterDemo&lt;/value&gt; --&gt; &lt;value&gt;roundDemo&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; ​ xml文件中为实现了接口的类创建了一个对象，然后通过Proxy类进行切片操作，生成了serviceProxy对象，使用接口的对象引用serviceProxy，即可实现JDK动态代理。 2.3 字节码增强技术​ 应用场景：没有实现接口的类。 ​ 如何实现：定义一个子类继承被代理类，重写接口的方法，增加切片。 未实现接口的类： 12345678910111213141516171819202122232425@Componentpublic class ServiceDemo2 &#123; private String name=&quot;hzhqian&quot;; private String url; protected int myName=99; public void setName(String name) &#123; this.name = name; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public void printName() &#123; System.out.println(&quot;name : &quot; + this.name); &#125; public void printURL() &#123; System.out.println(&quot;company : &quot; + this.url); &#125;&#125; xml配置文件： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;&lt;bean id=&quot;demoService2&quot; class=&quot;com.hugeyurt.springAOP.ServiceDemo2&quot;/&gt; &lt;bean id=&quot;beforeDemo&quot; class=&quot;com.hugeyurt.springAOP.DemoBeforeAdvice&quot; /&gt;&lt;bean id=&quot;afterDemo&quot; class=&quot;com.hugeyurt.springAOP.AfterAdviceDemo&quot; /&gt;&lt;bean id=&quot;roundDemo&quot; class=&quot;com.hugeyurt.springAOP.RoundAdviceDemo&quot; /&gt; &lt;bean id=&quot;serviceProxy1&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;demoService2&quot; /&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;beforeDemo&lt;/value&gt; &lt;!-- &lt;value&gt;afterDemo&lt;/value&gt; &lt;value&gt;roundDemo&lt;/value&gt; --&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; main函数： 12345678910111213public static void main(String[] args) &#123; // TODO Auto-generated method stub ApplicationContext appContext = new ClassPathXmlApplicationContext( new String[] &#123; &quot;beans.xml&quot; &#125;); ServiceDemo2 demo2 =(ServiceDemo2) appContext.getBean(&quot;serviceProxy1&quot;); System.out.println(demo2.getClass().getName()); System.out.println(demo2 instanceof IAopDemo); System.out.println(demo2.getClass().getSuperclass().getName()); demo2.printName(); demo2.printURL();&#125; ​ 根据生成的字节码对象，调用getInterface()函数判断该类是否实现了接口，若实现了，则使用JDK动态代理技术，反之，则创建一个类继承被代理类，完成切片操作。 3 小结​ 上述两种技术的原理都是重写被代理类的方法，在上一节中的中间代理类Dyn被写到了配置文件中。通过解析配置文件这一方法，更加体现了可维护性。 ​ 这个版本仍然存在问题，当被代理类中有多个方法时，每个方法都会被进行切片操作。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/categories/Spring/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://gigsider.com/tags/AOP/"},{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/tags/Spring/"}]},{"title":"AOP技术(1)","slug":"AOP_1","date":"2020-07-31T08:30:08.000Z","updated":"2020-08-19T08:21:36.115Z","comments":true,"path":"blogs/AOP_1/","link":"","permalink":"https://gigsider.com/blogs/AOP_1/","excerpt":"​ 摘要：静态代理模式实现的AOP、动态代理模式实现的AOP","text":"​ 摘要：静态代理模式实现的AOP、动态代理模式实现的AOP ​ 1 AOP介绍​ AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 ​ 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，利用了jdk动态代理技术，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。 2 静态代理模式实现AOP 接口类IHello： 12345public interface IHello &#123; void sayHello(String str); void sayBye();&#125; 实现类Hello： 12345678910111213public class Hello implements IHello&#123; @Override public void sayHello(String str) &#123; System.out.println(&quot;hello : &quot;+str); &#125; @Override public void sayBye() &#123; System.out.println(&quot;bye bye&quot;); &#125;&#125; 代理类ProxyHello： 1234567891011121314151617181920212223242526 /* * 静态代理模式实现AOP */public class ProxyHello implements IHello &#123; private IHello target; public ProxyHello(IHello target) &#123; this.target=target; &#125; @Override public void sayHello(String str) &#123; // TODO Auto-generated method stub Logger.start(); //Logger类，打印日志信息 target.sayHello(str);// 调用被代理对象的方法 Logger.end(); &#125; @Override public void sayBye() &#123; target.sayBye(); &#125;&#125; main函数： 123456789101112131415public class TestStaticProxy &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub IHello target=new Hello(); //target.sayHello(&quot;just a demo&quot;); target = new ProxyHello(target); target.sayHello(&quot; kitty&quot;); System.out.println(&quot;*************************&quot;); target.sayBye(); &#125;&#125; 3 动态代理模式实现AOP 代理类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class DynDemo implements InvocationHandler &#123; private Object obj;// 此时OBJ是要被代理的对象 private BeforeMethod befor; public DynDemo() &#123; &#125; // 此时参数obj是要被代理的对象 public DynDemo(Object obj) &#123; this.obj = obj; &#125; // 此时参数obj是要被代理的对象 public DynDemo(Object obj,BeforeMethod befor) &#123; this.obj = obj; this.befor=befor; &#125; //这个方法不是我们显示的去调用 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName()); if(method.getName().equals(&quot;hello&quot;)) &#123; return method.invoke(obj, args); //真正的调用它原对象 &#125; // System.out.println(&quot;before calling &quot; + method); if(befor!=null) befor.say(); //System.out.println(this.obj); Object result= method.invoke(obj, args); // 执行被代理对象的切入点 // obj.say(args); System.out.println(&quot;after calling &quot; + method); return result; &#125; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125; public BeforeMethod getBefor() &#123; return befor; &#125; public void setBefor(BeforeMethod befor) &#123; this.befor = befor; &#125; &#125; ​ 该代理类的作用：通过被代理的对象，确认切入点，增加额外的操作。 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//客户端：生成代理实例，并调用了say()方法 public class TestDemo &#123; public static void main(String[] args) throws Throwable&#123; // TODO Auto-generated method stub Demo target=new Demo();//这里指定被代理类 InvocationHandler ds=new DynDemo(target); System.out.println(ds); Class&lt;?&gt; cls=target.getClass();// 获取target对象类的字节码 //以下是一次性生成代理 IDemo subject=(IDemo)Proxy.newProxyInstance( cls.getClassLoader(),cls.getInterfaces(), ds); //这里可以通过运行结果证明subject是Proxy的一个实例，这个实例实现了IDemo接口 System.out.println(subject instanceof Proxy); //这里可以看出subject的Class类是$Proxy0,这个$Proxy0类继承了Proxy，实现了IDemo接口 // System.out.println(&quot;subject的Class类是：&quot;+subject.getClass().getName()); // System.out.println(&quot;subject的Class父类是：&quot;+subject.getClass().getSuperclass() // .getName()); /* System.out.println(&quot;\\n&quot;+&quot;subject实现的接口是：&quot;); Class&lt;?&gt;[] interfaces=subject.getClass().getInterfaces(); for(Class&lt;?&gt; i:interfaces)&#123; System.out.println(i.getName()); &#125; System.out.println(&quot;subject中的属性有：&quot;); Field[] field=subject.getClass().getSuperclass().getDeclaredFields(); for(Field f:field) &#123; System.out.print(f.getName()+&quot;, &quot;+f.getType()+&quot; # &quot;); f.setAccessible(true); System.out.println(f.get(subject)+&quot; #&quot;+f.getModifiers()); &#125; */ System.out.println(&quot;subject中的方法有：&quot;); Method[] method=subject.getClass().getDeclaredMethods(); for(Method m:method)&#123; System.out.print(m.getName()+&quot;, &quot;); &#125; /* */ System.out.println(&quot;\\n\\n&quot;+&quot;运行结果为：&quot;); subject.say(); subject.hello(); &#125; &#125; ​ 通过 Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), ds)方法，一次性生成代理，并通过返回的对象调用重写的方法。 Proxy.newProxyInstance()的具体实现逻辑： 1234567891011121314151617181920212223242526272829public class MyProxy implements IDemo&#123; private DynDemo target; public MyProxy(DynDemo target) &#123; this.target=target; &#125; @Override public void say() &#123; // TODO Auto-generated method stub try &#123; Method method=target.getObj().getClass().getDeclaredMethod(&quot;say&quot;, null); target.invoke(null, method, null); &#125;catch(Throwable e) &#123; e.printStackTrace(); &#125; &#125; @Override public void hello() &#123; // TODO Auto-generated method stub &#125;&#125; 4 小结4.1 静态代理模式下的AOP实现​ 通过一个实现接口的代理类，可以在不影响用户操作的时候添加其它功能，如记录日志等。 4.2 动态代理模式下的AOP实现​ 代理类可以动态地获取被代理的对象，通过该对象获取切入点，并添加操作。然后通过客户端实现被代理类的接口，调用Proxy.newProxyInstance()方法获取代理实例，并通过该方法返回的实例对象调用重写后的方法。 Proxy.newProxyInstance()完成的功能： 生成一个类（Proxy的子类）；Proxy$0 Proxy$0类会重写被代理类的接口。 每个方法调用中间代理类的invoke。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/categories/Spring/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://gigsider.com/tags/AOP/"},{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/tags/Spring/"}]},{"title":"MarkDown基础语法","slug":"MarkDown-First-Met","date":"2020-07-31T01:56:18.000Z","updated":"2020-08-19T13:20:57.240Z","comments":true,"path":"blogs/MarkDown-First-Met/","link":"","permalink":"https://gigsider.com/blogs/MarkDown-First-Met/","excerpt":"MarkDown 是一种轻量级标记语言。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。","text":"MarkDown 是一种轻量级标记语言。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 1 标题 12345# 一级标题名## 二级标题名### 三级标题名......###### 六级标题名 标题最多支持六级标题 2 文字 有些文字格式 MarkDown 的原生语法并不包括， 解决方案： 使用HTML的标签 使用HTML标签+CSS样式实现自己想要的字体格式 2.1 删除线使用”~~”: 1~~加上删除线的文字~~ 效果：加上删除线的文字 2.2 斜体使用”*”: 1*斜体的文字* 效果：斜体的文字 2.3 加粗使用”**”: 1**加粗的文字** 效果：加粗的文字 2.4 表格使用”|”来分隔不同的单元格，使用”-“来分隔表头和其他行，为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用”|”来标记单元格边界，在表头下方的分隔线标记中加入”:”，即可标记下方单元格内容的对齐方式： 12345| Name | Age | Sex || :--------- | :-------: | --------: || Ming | 19 | Male || Hong | 20 | Female || Gang | 18 | Male | 效果： Name Age Sex Ming 19 Male Hong 20 Female Gang 18 Male 2.5 下划线使用 HTML &lt;u&gt; 标签: 1&lt;u&gt;HTML u 标签&lt;&#x2F;u&gt; 使用 HTML 标签 + CSS 样式: 1&lt;span style&#x3D;&quot;border-bottom:2px dashed yellow;&quot;&gt;HTML 标签 + CSS 样式&lt;&#x2F;span&gt; u标签效果：HTML u 标签 HTML + CSS 效果: HTML 标签 + CSS 样式 2.6 上标、下标上标使用 HTML &lt;sup&gt; 标签: 1SUPER&lt;sup&gt;我是上标&lt;&#x2F;sup&gt; 下标使用 HTML &lt;sub&gt; 标签: 1SUB&lt;sub&gt;我是下标&lt;&#x2F;sub&gt; 上标效果：SUPER我是上标 下标效果：SUB我是下标 3 引用 使用”&gt;”: 1234&gt;朝辞白帝彩云间&gt;&gt;千里江陵一日还&gt;&gt;&gt;两岸猿声啼不住&gt;&gt;&gt;&gt;轻舟已过万重山 效果： 朝辞白帝彩云间 千里江陵一日还 两岸猿声啼不住 轻舟已过万重山 4 列表 4.1 有序列表使用”数字. “: 1231. 注意&quot;.&quot;后要有空格2. 列表3. 有序列表 效果： 注意”.”后要有空格 列表 有序列表 4.2 无序列表使用”*”或”+”或”-“: 123* 注意符号后要有空格+ 列表- 无序列表 效果： 注意符号后要有空格 列表 无序列表 5 代码 代码中的文本都会显示为原始内容。 5.1 代码块使用”```语言名称”: 123456​&#96;&#96;&#96;c++int main()&#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; return 0;&#125; 效果： 12345int main()&#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; return 0;&#125; 5.2 行内代码使用”``“: 1&#96;System.out.println(&quot;Hello world!&quot;)&#96; 效果：System.out.println(&quot;Hello world!&quot;) 6 分割线 使用”—“或”___”或”***”（符号数大于三个即可）: 123******----------_____ 效果： 7 跳转 使用”[现实的文本](跳转的链接)“: 1[我的博客](https:&#x2F;&#x2F;www.gigsider-fun.com) 使用”&lt;跳转的链接&gt;”: 1&lt;https:&#x2F;&#x2F;www.gigsider-fun.com&gt; []()效果：我的博客 &lt;&gt;效果：https://www.gigsider-fun.com 8 图片 使用”![图片的描述](图片的地址)“: 1![测试图片](MarkDown-First-Met&#x2F;test.png) 效果： 资料来源：https://space.bilibili.com/32157804","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/categories/MarkDown/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/tags/MarkDown/"}]},{"title":"Java NIO","slug":"Java-NIO","date":"2020-07-31T01:55:48.000Z","updated":"2020-08-15T10:45:15.787Z","comments":true,"path":"blogs/Java-NIO/","link":"","permalink":"https://gigsider.com/blogs/Java-NIO/","excerpt":"​ 摘要：NIO与传统IO、NIO构成组件、基于NIO实现的多人聊天","text":"​ 摘要：NIO与传统IO、NIO构成组件、基于NIO实现的多人聊天 ​ 1 NIO概念1.1 Unix定义了五种 I/O 模型 阻塞 I/O 非阻塞 I/O I/O 复用 信号驱动 I/O 异步 I/O 1.1.1 阻塞（Block）和非阻塞（NonBlock）阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式：阻塞：需要等待缓冲区中的数据准备好过后才处理其他的事情，否則一直等待在那里。非阻塞：进程访问数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。 1.1.2 同步与异步一个进程的IO调用步骤大致如下： 1、进程向操作系统请求数据 2、操作系统把外部数据加载到内核的缓冲区中 3、操作系统把内核的缓冲区拷贝到进程的缓冲区 4、进程获得数据完成自己的功能 当操作系统在把外部数据放到进程缓冲区的这段时间（即上述的第二，三步），如果应用进程是挂起等待的，那么就是同步IO，反之，就是异步IO Java中IO分为：BIO （Blocking IO）NIO （Non-blocking IO/New IO）AIO （Asynchronous IO/NIO2） 1.2 NIO模型图 2 NIO与传统IO的区别 IO NIO 面向流 面向缓冲 阻塞IO 非阻塞IO 无 selector 2.1 面向流与缓冲​ IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性 2.2 阻塞与非阻塞​ Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 2.3 选择器（Selector）​ Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 3 NIO构成组件Java NIO Channel通道和流非常相似，主要有以下几点区别：a.通道可以读也可以写，多功能高速通道，流一般来说是单向的（只能读或者写,如输入流与输出流）；b.通道可以异步读写；c.通道总是基于缓冲区Buffer来读写；正如上面提到的，我们可以从通道中读取数据，写入到buffer，也可以中buffer内读数据，写入到通道中；下面有个示意图： Channel的实现： FileChannel DatagramChannel SocketChannel ServerSocketChannel FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel. Buffer用于和Channel交互。我们从channel中读取数据到buffers里，从buffer把数据写入到channel，Buffer本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。 3.1 Buffer基本用法利用Buffer读写数据，通常遵循四个步骤： 把数据写入buffer； 调用flip； 从Buffer中读取数据； 调用buffer.clear()或者buffer.compact() 当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()或compact()方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。 Buffer有三个属性:容量，位置，上限（capacity, position , limit）buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。 3.2 Java NIO Selector​ Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。因此此可以实现单线程管理多个channels，也就是可以管理多个网络连接。 1.创建 要使用必须先创建一个： 创建一个selector可以通过selector.open()方法 2.注册 如果要监测channel,必须先把channel注册到Selector上，这个操作使用channel.register(), 3.监测 我们关注的channel状态，有四种基础类型可供监听：（观察客人发来的需求） Connect, Accept, Read ,Write 通过selectedKeys()，可以获取所有channel的相关信息，包括channel本身，以及channel的状态等信息，知道了channel的状态，我们就可以对channel进行相应的操作。 4 基于NIO实现的多人聊天4.1 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class NIOSelectorDemo &#123; public static void main(String[] args) throws IOException &#123; //创建ServerSocketChannel ServerSocketChannel server = ServerSocketChannel.open(); //绑定9090端口 server.bind(new InetSocketAddress(9090)); //设置为非阻塞 server.configureBlocking(false); //创建Selector Selector selector = Selector.open(); //当serversocket有连接请求时，监控这个事件 server.register(selector, SelectionKey.OP_ACCEPT); //创建SocketChannel的ArrayList用于管理客户端与服务端的连接 ArrayList&lt;SocketChannel&gt; clients = new ArrayList&lt;SocketChannel&gt;(); while(true) &#123; //阻塞，当至少有一个channel上有事件发生时，返回 //selector.select()返回了，意味着channel发生可处理事件 selector.select(); //获得可处理的事件selectionKeys（包含目标channel） Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = keys.iterator(); while( it.hasNext() ) &#123; SelectionKey key = it.next(); it.remove(); //表示可接收请求 if(key.isAcceptable()) &#123; ServerSocketChannel socket = (ServerSocketChannel)key.channel(); //接收到客户端请求时生成SocketChannel对象，用于和客户的数据传输 SocketChannel client = socket.accept(); //设置为非阻塞 client.configureBlocking(false); //注册进Selector client.register(selector, SelectionKey.OP_READ); //向客户端发送消息“hello” ByteBuffer buf = ByteBuffer.wrap(&quot;hello&quot;.getBytes()); client.write(buf); //将新客户端添加到客户列表里 clients.add(client); &#125; else if(key.isReadable()) &#123; SocketChannel client = (SocketChannel)key.channel(); //接收来自客户端的数据，组装成msg ByteBuffer buf = ByteBuffer.allocate(1024); client.read(buf); buf.flip(); String msg = client.getRemoteAddress()+&quot;==&gt;&quot;+new String(buf.array(),0,buf.limit()); //将msg发送给所有客户端 buf.clear(); buf.put(msg.getBytes()); buf.flip(); for(int i = 0; i &lt; clients.size(); i++) &#123; SocketChannel c = clients.get(i); c.write(buf); buf.rewind(); &#125; &#125; &#125; &#125; &#125;&#125; 4.2 客户端4.2.1 读线程1234567891011121314151617181920212223242526272829303132333435class ReadThread implements Runnable&#123; private SocketChannel socket = null; public ReadThread(SocketChannel socket) &#123; // TODO Auto-generated constructor stub this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub ByteBuffer buffer = ByteBuffer.allocate(1024); while(true) &#123; try &#123; int ret = socket.read(buffer); if(ret == -1) break; buffer.flip(); System.out.println(new String(buffer.array(),0,buffer.limit())); buffer.clear(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125; 4.2.2 写线程12345678910111213141516171819202122232425262728293031323334class WriteThread implements Runnable&#123; private SocketChannel socket = null; public WriteThread(SocketChannel socket) &#123; // TODO Auto-generated constructor stub this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub ByteBuffer buffer = ByteBuffer.allocate(1024); String msg = &quot;&quot;; Scanner scanner = new Scanner(System.in); while(true) &#123; msg = scanner.nextLine(); buffer.clear(); buffer.put(msg.getBytes()); buffer.flip(); try &#123; socket.write(buffer); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Java网络编程","slug":"Java-Web","date":"2020-07-21T11:03:17.000Z","updated":"2020-08-15T10:46:35.748Z","comments":true,"path":"blogs/Java-Web/","link":"","permalink":"https://gigsider.com/blogs/Java-Web/","excerpt":"​ Java语言作为最流行的网络编程语言，提供了强大的网络编程功能。 ​ 使用Java语言可以编写底层的网络通信程序，这是通过java.net包中提供的InetAddress类、URL类、Socket类以及ServerSocket等类实现的。","text":"​ Java语言作为最流行的网络编程语言，提供了强大的网络编程功能。 ​ 使用Java语言可以编写底层的网络通信程序，这是通过java.net包中提供的InetAddress类、URL类、Socket类以及ServerSocket等类实现的。 1 网络地址类InetAddress​ 要实现网络通信，首先需要知道计算机的地址。连接到Internet上的计算机使用IP地址或域名来唯一标识，在局域网上的计算机则可以使用名称标识。在java.net包中提供了InetAddress类来表示计算机地址。​ InetAddress类没有提供构造方法，要得到一个InetAddress类对象，需要使用该类的静态方法。 eg： 12345678910111213141516171819202122public class InetAddressDemo &#123; public static void main(String[] args) &#123; try &#123; InetAddress addr = InetAddress.getLocalHost(); System.out.println(addr.getHostAddress()); System.out.println(addr.getHostName()); System.out.println(addr.getAddress().length); InetAddress addr2 = InetAddress.getByName(&quot;www.acfun.cn&quot;); System.out.println(addr2.getHostAddress()); System.out.println(addr2.getHostName()); System.out.println(addr2.getAddress().length); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 2 URL编程2.1 URL与URL类​ URL是统一资源定位器（Uniform Resource Locator）的简写，它是WWW中网络资源定位的表示方法。​ URL的基本格式为： &lt;协议名://&gt;&lt;主机名&gt;[&lt;:端口号&gt;]&lt;/资源名&gt; 协议名表示资源使用的协议，如http、ftp、telnet、mailto或file等。 主机名为任何合法的主机域名，如www.njupt.edu.cn。 端口号是可选的，如果使用熟知端口号，则可以省略。 资源名一般用来指定远程主机上文件系统中文件的完整路径，如/index.html。 ​ URL类的实现： 12345678910111213141516171819202122232425262728293031323334static void Url1() &#123; try &#123; String s = &quot;https://www.baidu.com/&quot;; URL url = new URL(s); System.out.println(&quot;Protocol:&quot; + url.getProtocol()); //获取协议名 System.out.println(&quot;Host:&quot; + url.getHost()); //获取主机号 System.out.println(&quot;Port:&quot; + url.getPort());//获取端口号，若没有指定端口号则返回-1 System.out.println(&quot;DefaultPort:&quot; + url.getDefaultPort()); //获取默认端口号 System.out.println(&quot;File:&quot; + url.getFile()); //返回URL的文件名及路径 InputStream is = url.openStream(); InputStreamReader isr = new InputStreamReader(is,&quot;utf-8&quot;); int c = 0; while( ( c = isr.read() ) != -1) &#123; System.out.print((char)c); &#125; isr.close(); is.close(); System.out.println(&quot;finish&quot;); &#125; catch (MalformedURLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 2.2 URL的Connection类 ​ 通过URL的openStream()方法，只能获得InputStream对象。使用该对象只能从网络上读取数据。 ​ 如果希望不仅要从URL读取内容，还要向URL对象发送服务请求及参数，可以使用URLConnection类。 ​ 利用URL类提供的openConnection()方法，可以建立一个URLConnection对象。可以调用其getInputStream()方法和getOutputStream()方法得到输入流和输出流对象。 eg： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void Url2() &#123; String surl = &quot;https://www.baidu.com&quot;; try &#123; URL url = new URL(surl); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); conn.setDoOutput(true); //设置允许上传 //http请求的一些属性 conn.setRequestProperty(&quot;ContentType&quot;, &quot;text/plain&quot;); //打开连接输出流，输出数据 OutputStream os = conn.getOutputStream(); FileInputStream fis = new FileInputStream(&quot;test.txt&quot;); int c = 0; System.out.println((char)fis.read()); while( (c=fis.read()) != -1) &#123; os.write(c); &#125; fis.close(); os.close(); //当打开输入流的时候，请求发出，并得到响应 InputStream is = conn.getInputStream(); InputStreamReader reader = new InputStreamReader(is,&quot;utf-8&quot;); c = 0; while( (c=reader.read()) != -1) &#123; System.out.print((char)c); &#125; reader.close(); is.close(); System.out.println(&quot;read finish&quot;); &#125; catch (MalformedURLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 3 Java套接字编程3.1 端口号和套接字​ 在网络上，很多应用都是采用客户/服务器（C/S）结构的。实现网络通信必须将两台机器连接起来建立一个双向通信链路，这个双向通信链路的每一端称为一个套接字（Socket）。 ​ 在Internet上使用IP地址唯一标识一台主机。​ 一台主机可能提供多种服务，仅用IP地址不能唯一标识一个服务。通常使用一个整数来标识该机器上的某个服务，这个整数就是端口号（Port）。​ 端口号是用16位整数标识，共有65536个端口号。端口号并不是机器上实际存在的物理位置，而是一种软件上的抽象。 ​ 一个TCP连接由它的两个端点来标识，而每一个端点又是由IP地址和端口号决定的。TCP连接的端点称为套接字，套接字是由IP地址和端口号构成的，如下图所示。 ​ 这里，131.6.23.13为IP地址，1500为端口号，因此套接字为131.6.23.13，1500。 3.2 套接字通信​ 运行在一台特定机器上的某个服务器（如HTTP服务器）都有一个套接字绑定到该服务器上。服务器只是等待、监听客户的连接请求。​ 在客户端，客户机需要知道服务器的主机名和端口号。为了建立连接请求，客户机试图与服务器机上的指定端口号上的服务连接，这个请求过程如下图所示。 ​ 如果正常，服务器将接受连接请求。一旦接受了请求，服务器将创建一个新的绑定到另一个端口号的套接字，然后使用该套接字与客户通信。这样，服务器可以使用原来的套接字继续监听连接请求，如图所示。 ​ 在客户端，如果连接被接受，就会创建一个套接字，客户就可以使用该套接字与服务器通信。注意，客户端的套接字并没有绑定到与服务器连接的端口号上，相反客户被指定客户程序所在机器上的一个端口号上。现在客户与服务器就可以读写套接字进行通信了。 3.3 套接字类​ 为了实现套接字通信，在java.net包中提供了两个类：Socket和ServerSocket。它们分别实现连接的客户端和服务器端的套接字。 3.3.1 Socket类Client和Server都需定义出该类的对象。创建对象时，端口号必须对应。\\ public InputStrean getInputStream() throws IOException 获得套接字绑定的数据输入流。 public OutputStream getOutputStream() throws IOException 获得套接字绑定的数据输出流。 3.3.2 ServerSocket类​ 用在服务器端。客户与服务器通信，客户向服务器提出请求，服务器监听请求，一旦监听到客户请求，服务器也要建立一个套接字。 3.3.3 客户和服务器通信的实例包括以下4个基本步骤：（1）创建套接字对象。（2）打开连接到套接字的输入输出流。（3）按照一定协议对套接字进行读写操作。（4）关闭套接字对象。 eg: 服务器代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Server &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; //服务器监听在本机的8000端口 ServerSocket server = new ServerSocket(8000); System.out.println(&quot;server start..&quot;); //当接受到客户端请求后，生成一个socket，用于和客户端的数据传输 Socket socket = server.accept();//阻塞，等待客户端连接请求 System.out.println(socket.getRemoteSocketAddress());//得到Client的Socket地址 System.out.println(socket.getLocalSocketAddress());//得到Server的Socket地址 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); os.write(&quot;hello&quot;.getBytes()); os.flush(); byte[] bts = new byte[20]; //采用的是阻塞IO（若没有数据，就一直等待） int count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Client say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; &#125; is.close(); os.close(); System.out.println(&quot;server stop..&quot;); server.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 客户端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Client &#123; public static void main(String[] args) &#123; try &#123; //参数是要连接的服务器地址和端口，发出连接请求，建立连接 Socket socket = new Socket(&quot;localhost&quot;,8000); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] bts = new byte[20]; int count = is.read(bts, 0, 20); System.out.println(&quot;Server say:&quot;+new String(bts,0,20)); count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Server say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; &#125; is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 3.3.4 多个客户端和服务器通信实例Server： 12345678910111213141516171819202122232425262728293031public class ServerDemo &#123; public static void main(String[] args) &#123; ServerSocket server = null; try &#123; server = new ServerSocket(9000); while( true ) &#123; Socket socket = server.accept(); //启动客户端线程，独立完成通信 new Thread(new ClientThreadDemo(socket)).start(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;server start fail..&quot;); &#125;finally &#123; try &#123; if(server !=null) server.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Client: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Client &#123; public static void main(String[] args) &#123; try &#123; //参数是要连接的服务器地址和端口，发出连接请求，建立连接 Socket socket = new Socket(&quot;localhost&quot;,9000); InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); byte[] bts = new byte[20]; int count = is.read(bts, 0, 20); System.out.println(&quot;Server say:&quot;+new String(bts,0,20)); count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Server say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; &#125; is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; ClientThread: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ClientThreadDemo implements Runnable&#123; private Socket socket; public ClientThreadDemo(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; // TODO Auto-generated method stub InputStream is = null; OutputStream os = null; try &#123; is = socket.getInputStream(); os = socket.getOutputStream(); os.write(&quot;hello&quot;.getBytes()); os.flush(); byte[] bts = new byte[20]; //采用的是阻塞IO（若没有数据，就一直等待） int count = 0; String str = &quot;&quot;; Scanner scanner = new Scanner(System.in); while( true ) &#123; count = is.read(bts, 0, 20); str = new String(bts,0,count); System.out.println(&quot;Client say:&quot;+str); if( str.equals(&quot;bye&quot;)) break; str = scanner.nextLine(); os.write(str.getBytes()); os.flush(); if( str.equals(&quot;bye&quot;) ) break; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(is != null) is.close(); if(os != null) os.close(); if(socket != null) socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 4 数据报通信4.1 流式通信和数据报通信​ 当编写网络程序时，有两种通信可供选择：流式通信和数据报通信。 流式通信 数据报通信 流式通信使用TCP协议，该协议是面向连接的协议。使用这种协议要求发送方和接收方都要建立套接字，一旦两个套接字建立起来，它们就可以进行双向通信，双方都可以发送和接收数据。 数据报通信使用UDP协议，该协议是一种无连接的协议。使用这种协议通信，每个数据报都是一个独立的信息单元，它包括完整的目的地址，数据报在网络上以任何可能的路径传往目的地，因此数据能否到达目的地、到达的时间以及内容的正确性都是不能保证，该协议提供的是不可靠的服务。 对于TCP，是一个面向连接的协议，在通信之前必须建立双方的连接，因此在TCP中多了一个建立连接的时间。 使用UDP时，每个数据报都给出了完整的地址信息，无需建立发送方和接收方的连接。 使用TCP就没有大小限制，一旦连接建立，就可以传输大量数据。 使用UDP传输数据时有大小限制，每个数据报必须不大于64KB。 TCP是可靠协议，确保接收方完全正确地获取发送方发送的数据。 UDP是不可靠协议，发送方发送的数据不一定以相同的次序到达接收方。 TCP使用较广泛，如TELNET远程登录、FTP文件传输都需要不定长度的数据可靠地传输，因此使用TCP协议。 UDP比较简单，需要较少的监护，因此常用于局域网分散系统中的客户/服务器应用程序。 4.2 DatagramSocket和DatagramPacket​ 用UDP编写客户/服务器程序时，无论是客户方还是服务器方，首先都要建立一个DatagramSocket对象用来接收或发送数据报，然后使用DatagramPacket类对象作为传输数据的载体。 4.2.1 数据报通信实例Server: 1234567891011121314151617181920212223242526272829303132public class UDPServerDemo &#123; public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(9090); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, 1024); socket.receive(packet); //阻塞 System.out.println(&quot;Client address:&quot;+packet.getSocketAddress()); System.out.println(&quot;Client data:&quot;+new String(packet.getData(),0,packet.getLength())); String str = &quot;welcome&quot;; //从接收到的数据报取得对方的地址和端口 DatagramPacket spacket = new DatagramPacket(str.getBytes(), str.getBytes().length, packet.getAddress(), packet.getPort()); socket.send(spacket); socket.close(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Client: 12345678910111213141516171819202122232425262728293031323334public class UDPClientDemo &#123; public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(9091); String str = &quot;hello server&quot;; DatagramPacket spacket = new DatagramPacket(str.getBytes(), str.getBytes().length,InetAddress.getByName(&quot;localhost&quot;),9090); socket.send(spacket); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf, 1024); socket.receive(packet); //阻塞 System.out.println(packet.getSocketAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); socket.close(); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.2.2 基于线程实现一对一通信UDPPeerDemo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class UDPReceiveThread implements Runnable&#123; private DatagramSocket socket; public UDPReceiveThread(DatagramSocket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; byte [] buffer = new byte[1024]; DatagramPacket p = null; while( true ) &#123; p = new DatagramPacket(buffer, 1024); try &#123; socket.receive(p); System.out.println(&quot;Data: &quot; + new String(p.getData(),0,p.getLength())); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; &#125; &#125;public class UDPPeerDemo implements Runnable&#123; private DatagramSocket socket; private int port; private int rport; public UDPPeerDemo(int port,int rport) &#123; this.port = port; this.rport = rport; try &#123; socket = new DatagramSocket(port); &#125; catch (SocketException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(&quot;套接字创建失败&quot;); &#125; &#125; @Override public void run() &#123; new Thread(new UDPReceiveThread(socket)).start(); //启动接收线程 String s = &quot;&quot;; Scanner scanner = new Scanner(System.in); DatagramPacket packet = null; while( scanner.hasNextLine() ) &#123; s = scanner.nextLine(); try &#123; packet = new DatagramPacket(s.getBytes(), s.getBytes().length, InetAddress.getByName(&quot;localhost&quot;), rport); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); continue; &#125; try &#123; socket.send(packet); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); break; &#125; &#125; socket.close(); &#125;&#125; UDPDemo: 123456public class UDPDemo &#123; public static void main(String[] args) &#123; new Thread(new UDPPeerDemo(9090, 9091)).start(); &#125;&#125; UDPDemo2: 123456public class UDPDemo2 &#123; public static void main(String[] args) &#123; new Thread(new UDPPeerDemo(9091, 9090)).start(); &#125;&#125; 5 小结​ 通过网络资源定位器可以指向并获取网络上丰富的资源。基于TCP的网络数据传输是一种可靠的有连接的网络数据传输。这种传输方式是目前最常用的网络数据传输方式。在基于TCP的网络程序中，服务器端与客户端的程序编写稍有些不同。​ 基于UDP的网络数据传输是一种可靠的无连接的网络数据传输。在基于UDP的网络程序设计中，服务器端与客户端的程序编写基本上是相类似的。在Java的包java.net还含有很多用于网络数据传输的类和接口，为网络编程提供了方便。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"网络编程","slug":"网络编程","permalink":"https://gigsider.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO流","slug":"Java-IO","date":"2020-07-20T08:24:58.000Z","updated":"2020-08-15T10:43:03.314Z","comments":true,"path":"blogs/Java-IO/","link":"","permalink":"https://gigsider.com/blogs/Java-IO/","excerpt":"​ 摘要：File类、字节流和字符流、数据流、缓冲流、随即流、对象流","text":"​ 摘要：File类、字节流和字符流、数据流、缓冲流、随即流、对象流 ​ 1 流的概念1.1 流（1）流是一个无结构化的数据组成的序列，流中的数据没有任何格式和含义，只是以字节或字符形式进行流入或流出。 （2）数据流的流入和流出都是以程序本身作为核心，流入是指数据从外部数据源流入到程序内部；流出是指数据从程序内部向外部流出到数据的目的地。 （3）不管是流入还是流出，其数据的流动都是通过一个管道进行的，管道两端分别连接数据源和数据目的地。 （4）流的本质就是进行数据传输，因此Java根据数据传输的特性将流抽象成各种类，以方便进行数据操作。 1.2 流的分类 根据处理数据类型，可以分为字节流和字符流。 根据数据的流向可以分为输入流和输出流。 根据处理数据功能，可以分为实体流和装饰流。 实体流对数据不做任何处理，只完成基本的读写操作。 装饰流是在实体流的基础上，提供更高级的功能。 这些流都在java.io包中。 1.2.1 字节流 在数据传输过程中以字节为单位进行输入和输出。 适用于传输各种类型的文件或数据。 在字节输入流中，InputStream 类是所有的输入字节流的父类，它是一个抽象类。 其子类中的ByteArrayInputStream、FileInputStream 是两种基本的实体流。 ObjectInputStream 和所有FilterInputStream 的子类都是装饰流。 在字节输出流中，OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的实体流。 ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 1.2.2 字符流 在数据传输过程中以字符为单位进行输入和输出。 根据字符编码表，一个字符占用两个字节，因此字符流只适用于字符类型数据的处理。 在字符输入流中，Reader 是所有的输入字符流的父类，它是一个抽象类。 InputStreamReader 是一个连接字节流和字符流的桥梁，它使用指定的字符集读取字节并转换成字符。 其FileReader子类可以更方便地读取字符文件，也是常用的Reader流对象。 在字符输出流中，Writer是所有的输出字符流的父类，也是一个抽象类。 相对输入流的子类，输出流当中也有相应的输出子类，只是数据传输方向相反。 这些类有OutputStreamWriter及其子类FileWriter、 CharArrayWriter、StringWriter 、BufferedWriter 、PipedWriter等。 2 File类2.1 文件对象与文件属性​ 文件用文件类的对象表示，有了文件对象就可以获取文件属性。 返回类型 方法名 功能 File(String filename) 在当前路径下，创建一个名字为filename的文件 File(String path,String filename) 在给定的path路径下，创建一个名字为filename的文件 String getName() 获取此文件（目录）的名称 String getPath() 获取路径名字符串 long length() 获取文件的长度。如果表示目录，则返回值不确定 boolean canRead() 判断文件是否可读 String getAbsolutePath() 获取路径名字符串 boolean canWrite() 判断文件是否可写 boolean canExecute() 判断文件是否执行 boolean exists() 判断文件（目录）是否存在 boolean isFile() 判断文件是否是一个标准文件 boolean isDirectory() 判断文件是否是一个目录 boolean isHidden() 判断文件是否是一个隐藏文件 long lastModified() 判断文件最后一次被修改的时间 2.2 目录​ Java把目录作为一种特殊的文件进行处理，它除了具备文件的基本属性如文件名、所在路径等信息以外，同时也提供了专用于目录的一些操作方法。 返回类型 方法名 功能 boolean mkdir() 创建一个目录，并返回创建结果。成功返回true，失败（目录已存在）返回false boolean mkdirs() 创建一个包括父目录在内的目录。创建所有目录成功返回true，如果失败返回false，但要注意的是有可能部分目录已创建成功 String[] list() 获取目录下字符串表示形式的文件名和目录名 String[] list(FilenameFilter filter) 获取满足指定过滤器条件的字符串表示形式的文件名和目录名 File[] listFiles() 获取目录下文件类型表示形式的文件名和目录名 File[] listFiles(FileFilter filter) 获取满足指定过滤器文件条件的文件表示形式的文件名和目录名 File[] listFiles(FilenameFliter fliter) 获取满足指定过滤器路径和文件条件的文件表示形式的文件名和目录名 2.3 文件的操作 创建文件File类的方法： public boolean createNewFile() File file = new File(“D:\\\\”,”hello.txt”) file.createNewFile(); 删除文件File类中的方法: file.delete() 运行可执行文件 首先利用Runtime类的静态方法创建一个Runtime对象: Runtime ec = Runtime.getRuntime(); 然后用ec调用方法： Process exec(String command); 2.4 Scanner类与文件​ 利用Scanner类的对象还可以从文件中读取数据: Scanner input=new Scanner(文件类对象) ​ 创建的Scanner类的对象使用read()方法即可从文件中读数据。 ​ 读数据时默认以空格作为数据的分隔标记。 3 字节流和字符流3.1字节流​ 抽象类InputStream和抽象类OutputStream是所有字节流类的根类，其他字节流类都继承自这两个类。 3.1.1 字节输入流InputStream​ 字节输入流的作用是从数据输入源（例如从磁盘、网络等）获取字节数据到应用程序（内存）中。 返回类型 方法名 功能 int read() 从输入流中读取下一个字节，返回读入的字节数据；如果读到末尾，返回-1 int read(byte b[]) 从输入流中读取一定数量的字节保存到字节数组中，并返回实际读取的字节数 | int | read(byte b[],int off,int len) | 从输入流中读取最多len个字节，保存到数组b中从off开始的位置，并返回实际读入的字节数；如果off+len 大于b.length，或者off 和len中有一个是负数，那么会抛出IndexOutOfBoundsException异常 || long | skip(long n) | 从输入流中跳过并丢弃n个字节，并返回实际跳过的字节数 || void | close() | 关闭输入流，释放资源。对流的读取完毕后调用该方法以释放资源 || int | available() | 返回此输入流可以读取（或跳过）的估计字节数 || void | mark(int readlimit) | 在输入流中标记当前的位置。参数readlimit为标记失效前最多读取的字节数。如果读取的字节数超出此范围则标记失效 || void | reset() | 将输入流重新定位到最后一次调用 mark 方法时的位置 || boolean | markSupported() | 测试此输入流是否支持 mark 和 reset 方法。只有带缓存的输入流支持标记功能 | 3.1.2 文件字节输入流类FileInputStream​ 在进行字节输入流操作时，经常使用的是InputStream类的子类FileInputStream，实现简单的文件数据读取。 ​ FileInputStream类的常用构造方法： public FileInputStream(File file) throws FileNotFoundException public FileInputStream(String name) throws FileNotFoundException ​ 通过给定的File对象和文件创建文件字节输入流对象。 ​ 在创建输入流时，如果文件不存在或出现其他问题，会抛出FileNotFoundException异常，所以要注意捕获。 字节输入流读数据步骤： 设定输入流的数据源 创建指向这个数据源的输入流 从输入流中读取数据 关闭输入流 3.1.3 字节输出流OutputStream​ 字节输出流的作用是将字节数据从应用程序（内存）中传送到输出目的地，如外部设备、网络等。 ​ 字节输出流OutputStream的常用方法。 返回类型 方法名 功能 void write(int b) 将整数b的低8位写到输出流 void write(byte b[]) 将字节数组中数据写到输出流 | void | write(byte b[ ],int off,int len) | 从字节数组b的off处写len个字节数据到输出流 || void | flush() | 强制将输出流保存在缓冲区中的数据写到输出流 || void | close() | 关闭输出流，释放资源 | 3.1.4 文件字节输出流类FileOutputStream​ 在进行字节输出流操作时，经常使用的是OutputStream类的子类FileOutputStream，用于将数据写入File或其他的输出流。 ​ FileOutputStream类的常用构造方法： public FileOutputStream(File file) throws IOException public FileOutnputStream(String name) throws IOException public FileOutputStream(File file, boolean append) throws IOException public FileOutputStream(String name, boolean append) throws IOException 字节输出流写数据步骤： 设定输出流的目的地 创建指向这目的地输出 向输出流中写入数据 关闭输出流 ​ 在完成写操作过程中，系统会将数据暂存到缓冲区中，缓冲区存满后再一次性写入到输出流中。 ​ 执行close()方法时，不管缓冲区是否已满，都会把其中的数据写到输出流。 3.2 字符流​ 字符流通常用于文本文件的传输。 ​ 抽象类Reader和抽象类Writer是所有字符流类的根类，其他字符流类都继承自这两个类。 ​ 其中一些子类还在传输过程中对数据做了进一步处理以方便用户的使用。 3.2.1 字符输入流Reader​ 字符输入流Reader是所有字符输入流类的父类，实现从数据源读入字符数据。常用方法有： 返回类型 方法名 功能 int read() 从输入流读取单个字符 int read(char[] cbuf) 从输入流读取字符保存到数组cbuf中，返回读取的字符数，如果已到达流的末尾，则返回 -1 int read(char[] cbuf,int off,int len) 从输入流读取最多len个字符保存到字符数组cbuf中，存放的起始位置在off处。返回：读取的字符数，如果已到达流的末尾，则返回 -1 | long | skip(long n) | 跳过n个字符。返回：实际跳过的字符数 || void | mark(int readAheadLimit) | 标记流中的当前位置 || void | reset() | 重置该流 || boolean | markSupported() | 判断此流是否支持 mark() 操作 || void | close() | 关闭该流，释放资源 | 3.2.2 文件字符输入流FileReader​ 进行字符输入流操作时，经常使用的是Reader类的子类FileReader，用于从输入流读取数据。 ​ FileReader类的常用构造方法： public FileReader(File file) throws FileNotFoundException public FileReader(String name) throws FileNotFoundException ​ 通过给定的File对象或文件名创建字符输入流。 ​ 在创建输入流时，如果文件不存在或出现其他问题，会抛出FileNotFoundException异常。 3.2.3 字符输出流Writer 返回类型 方法名 功能 void write(int c) 将整数c的低16位写到输出流 void write(char[] cbuf) 将字符数组中数据写到输出流 void write(cbuf[ ],int off,int len) 从字符数组cbuf的off处开始取len个字符写到输出流 void write(String str) 将字符串写到输出流 void write(String str,int off,int len) 从字符串str的off处开始取len个字符数据写到输出流 void flush() 强制将输出流保存在缓冲区中的数据写到输出 void close() 关闭输出流，释放资源 3.2.4 文件字符输出流FileWriter类​ FileWriter类和字节流FileOutputStream类相对应，实现字符的输出操作，实现方法也基本相同。FileWriter类的常用构造方法： public FileWriter(File file) throws IOException public FileWriter(String name) throws IOException public FileWriter(File file, boolean append) throws IOException public FileWriter(String name, boolean append) throws IOException ​ 如果第二个参数为 true，则将字符写入文件末尾处，而不是写入文件开始处。 ​ 如果文件不存在或出现其他问题，会抛出IOException异常。 4 数据流​ 数据流是Java提供的一种装饰类流。 ​ 建立在实体流基础上，让程序不需考虑数据所占字节个数的情况下就能够正确地完成读写操作。 ​ DataInputStream类和DataOutputStream类分别为数据输入流类和数据输出流类。 4.1 数据输入流​ 数据输入流DataInputStream类允许程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。 ​ DataInputStream类的常用方法： 返回类型 方法名 功能 DataInputStream(InputStream in) 使用指定的实体流 InputStream 创建一个DataInputStream boolean readBoolean() 读取一个布尔值 byte readByte() 读取一个字节 char readChar() 读取一个字符 long readLong() 读取一个长整型数 int readInt() 读取一个整数 short readShort() 读取一个短整型数 float readFloat() 读取一个Float数 double readDouble() 读取一个Double数 String readUTF() 读取一个UTF字符串 int skipBytes(int n) 跳过并丢弃n个字节，返回实际跳过的字节数 4.2 数据输出流​ 数据输出流DataOutputStream类允许程序以适当方式将基本Java数据类型写入输出流中。DataOutputStream类的常用方法： 返回类型 方法名 功能 DataOuputStream (OutputStream out) 创建一个新的数据输出流，将数据写入指定基础输出流 void writeBoolean(Boolean v) 将一个布尔值写出到输出流 void writeByte(int v) 将一个字节写出到输出流 void writeBytes(String s) 将字符串按字节（每个字符的高八位丢弃）顺序写出到输出流中 void writeChar(int c) 将一个 char 值以2字节值形式写入输出流中，先写入高字节 void writeChars(String s) 将字符串按字符顺序写出到输出流 void writeLong(long v) 将一个长整型数写出到输出流 void writeInt(int v) 将一个整数写出到输出流 void writeShort(int v) 将一个短整型数写出到输出流 void writeFloat(float v) 将一个Float数写出到输出流 void writeDouble(double v) 将一个Double数写出到输出流 void writeUTF(String s) 将一个字符串用UTF-8编码形式写出到输出流 int size() 返回写到数据输出流中的字节数 void flush() 清空输出流，使所有缓冲中的字节被写出到流中 5 缓冲流​ 缓冲流是在实体I/O流基础上增加一个缓冲区，应用程序和I/O设备之间的数据传输都要经过缓冲区来进行。 ​ 缓冲流分为缓冲输入流和缓冲输出流。 ​ 缓冲输入流是将从输入流读入的字节/字符数据先存在缓冲区中，应用程序从缓冲区而不是从输入流读取数据； ​ 缓冲输出流是在进行数据输出时先把数据存在缓冲区中，当缓冲区满时再一次性地写到输出流中。 ​ 使用缓冲流可以减少应用程序与I/O设备之间的访问次数，提高传输效率； ​ 可以对缓冲区中的数据进行按需访问和预处理，增加访问的灵活性。 5.1 缓冲输入流​ 包括字节缓冲输入流BufferedInputStream类和字符缓冲输入流BufferedReader类。 5.1.1 字节缓冲输入流BufferedInputStream类​ 先通过实体输入流（例如FileInputStream类）对象逐一读取字节数据并存入缓冲区，应用程序则从缓冲区中读取数据。​ 构造方法： public BufferedInputStream(InputStream in) public BufferedInputStream(InputStream in,int size) ​ size:指定缓冲区的大小。 ​ BufferedInputStream类继承自InputStream，所以该类的方法与InputStream类的方法相同。 5.1.2 字符缓冲输入流BufferedReader类​ 与字节缓冲输入流BufferedInputStream类在功能和实现上基本相同。它只适用于字符读入。 ​ 构造方法： public BufferedReader(Reader in) public BufferedReader(Reader in,int sz) ​ BufferedReader类继承自Reader，所以该类的方法与Reader类的方法相同。 ​ 新增按行读取的方法：String readLine() ​ 该方法返回值为该行不包含结束符的字符串内容，如果已到达流末尾，则返回 null。 5.2 缓冲输出流​ 缓冲输出流包括字节缓冲输出流BufferedOutputStream类和字符缓冲输出流BufferedWriter类。 5.2.1 字节缓冲输出流BufferedOutputStream类​ 完成输出操作时，先将字节数据写入缓冲区，当缓冲区满时，再把缓冲区中的所有数据一次性写到底层输出流中。 ​ 构造方法： public BufferedOutputStream(OutputStream out)public BufferedOutputStream(OutputStream out,int size) ​ BufferedOutputStream类继承自OutputStream，所以该类的方法与OutputStream类的方法相同。 5.2.2 字符缓冲输出流BufferedWriter类​ 与字节缓冲输出流BufferedOutputStream类在功能和实现上是相同的。只适用于字符输出。 ​ BufferedWriter类的构造方法： public BufferedWriter(Writer out)public BufferedWriterr(Writer out,int sz) ​ BufferedWriter类继承自Writer，所以该类的方法与Writer类的方法相同。 ​ 新增写行分隔符的方法：String newLine()行分隔符字符串由系统属性 line.separator 定义。 6 随机流​ 随机流RandomAccessFile类创建的对象既可以作为输入流，也可以作为输出流，因此建立一个随机流就可以完成读写操作。 ​ RandomAccessFile类是java.lang.Object根类的子类。 ​ RandomAccessFile类的实例对象支持对随机访问文件的读取和写入。 ​ 随机流可以用于多线程下载或多个线程同时写数据到文件，为快速完成访问提供了便利。 6.1 RandomAccessFile类 返回类型 方法名 功能 RandomAccessFile(String name, String mode) 参数name为待访问的文件名，file待访问的文件。参数mode为读写模式，常用的值有：“r”以只读方式打开文件，如果进行写操作会产生异常；“rw”：以读写方式打开文件，如果文件不存在，则创建 RandomAccessFile(File file, String mode) 同上 int read() 从文件中读取一个数据字节并以整数形式返回此字节 int read(byte[] b) 从文件中读取最多b.length 个数据字节到b数组中，并返回实际读取的字节数 int read(byte[] b, int off, int len) 从文件中读取len个字节数据到b数组中。off为字节在数组中存放的地址 XXX readXXX() 从文件中读取一个XXX类型数据，XXX包括：boolean，byte，char，short，int，lang，float，double void write(int b) 写入指定的字节 void write(byte[] b) 写入字节数组内容到文件 void writeXXX(XXX v) 写入指定类型数据到文件，XXX包括：boolean，byte，char，short，int，lang，float，double void writeChars(String s) 写入字符串到文件 void writeUTF(String s) 按UTF-8编码形式将字符串写入到文件 long getFilePointer() 获取文件的当前偏移量 void seek(long pos) 设置文件的指针偏移量 long length() 获取文件的长度 void setLength(long newLength) 设置此文件的长度。 如果 length 方法返回的文件的现有长度大于 newLength 参数，则该文件将被截短。超过则加大文件，多出部分没有内容 int skipBytes(int n) 跳过输入的 n 个字节并丢弃跳过的字节 void close() 关闭文件流，释放资源 ​ 由于编码格式不同当进行字符串读取的时候，有时会出现“乱码”的现象。 ​ 对字符串重新进行编码可以解决乱码问题： 先读字符串：String str = in.readLine(); 再将字符串恢复成标准字节数组：byte [] b=str.getBytes(“iso-8859-1”); 最后将字节数组按当前机器的默认编码重新转化为字符串：String result=new String(b); 显式地指明编码类型，可以直接给出编码类型：String result=new String(b,”GB2312”); 7 对象流​ 对象流是在实体流基础上，通过对对象数据的处理和变换，实现对象的永久保存和读取。 ​ ObjectInputStream和ObjectOutputStream分别是对象输入流类和对象输出流类，它们也是InputStream和OutputStream类的子类。 ​ 通过对象输出流，可以把对象写入到文件或进行网络传输。 ​ 对象输入流类可以从文件或网络上，把读取的数据还原成对象。 ​ 要想实现对象的传输，待传输的对象要先进行序列化处理，才能保证对象能准确地保存和读取。 7.1 对象的序列化​ 对象的序列化是指把对象转换成字节序列的过程，而把字节序列恢复为对象的过程称为对象的反序列化。 ​ 一个类如果实现了java.io.Serializable接口，这个类的实例（对象）就是一个序列化的对象。 ​ Serializable接口中没有方法。实现了该接口的对象进行输出时，JVM将按照一定的格式（序列化信息）转换成字节进行传输和存储到目的地。 ​ 对象输入流从文件或网络上读取对象时，会先读取对象的序列化信息，并根据这一信息创建对象。 7.2 对象输入流与对象输出流7.2.1 对象输入流ObjectInputStream类​ 实现对象的输入操作。构造方法： public ObjectInputStream(InputStream in) ​ 类中的方法：Object readObject()从ObjectInputStream流中读取对象。 7.2.2 对象输出流ObjectOutputStream类​ 实现对象的输出操作。构造方法： ​ public ObjectOutputStream(OutputStream out) ​ 类中的方法：void writeObject(Object o)将指定对象o写入ObjectOutputStream流中。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"IO流","slug":"IO流","permalink":"https://gigsider.com/tags/IO%E6%B5%81/"}]},{"title":"xml解析","slug":"xml","date":"2020-05-23T10:54:37.000Z","updated":"2020-08-15T11:21:37.497Z","comments":true,"path":"blogs/xml/","link":"","permalink":"https://gigsider.com/blogs/xml/","excerpt":"​ 摘要：XML语法、XML解析方式、Java解析XML、Jdom、Dom4j","text":"​ 摘要：XML语法、XML解析方式、Java解析XML、Jdom、Dom4j ​ 1 XML概念一个完整的XML文件： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt; &lt;/note&gt; xml概念： XML指可扩展标记语言（Extensible Markup Language）； XML是一种标记语言，很类似HTML； XML的设计宗旨是传输数据，而非显示数据； XML标签没有被预定义，您需要自行定义标签； XML被设计为具有自我描述性； XML是W3C的推荐标准 xml特点： XML是SGML的简化版本 XML提示了数据本身的意义 XML是可扩展的 XML是跨平台的 XML是结构化的 XML是基于文本的 XML的数据与其显示格式是分离的 XML文档比HTML文档更容易访问 XML是一种树形存储结构 xml与HTML的差异： XML不是HTML的替代。XML和HTML为不同的目的而设计： XML被设计为传输和存储数据，其焦点是数据的内容； HTML被设计用来显示数据，其焦点是数据的外观； HTML旨在显示信息，而XML旨在传输信息。 HTML是一个大小写不敏感的，XML是大小写敏感的。 HTML有着固定的显示标准，XML显示是依赖应用灵活定义 xml应用场景 作为系统或应用的配置文件使用，如tomcat中的web.xml 作为应用程序的数据存储文件或日志存储文件 数据库的功能之一，支持XML存储 WebService协议用语言，soap协议 IM通信协议标准，如XMPP协议 部分矢量图像存储格式，如果SVG图片 部分流媒体协议，如果CML 2 XML语法 所有XML元素都须有关闭标签 ，而不像部分的HTML标签 声明语句也可以不要 XML 标签对大小写敏感 必须正确嵌套 文档必须有根元素 属性值须加引号 转义字符 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记 CDATA 是不会被解析器解析的文本 元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。 3 XML解析方式两种方式：SAX,DOM SAX适于处理下面的问题： 对大型文档进行处理。 只需要文档的部分内容，或者只需要从文档中得到特定信息。 想创建自己的对象模型的时候。 DOM适于处理下面的问题： 需要对文档进行修改 需要随机对文档进行访问，例如XSLT解析器。 需要校验XML的合法性，完整性 4 Java解析XML DOM解析器 ​ 由W3C提供的接口，它将整个XML文档读入内存，构建一个DOM树来对各个节点(Node)进行操作。（参见代码） SAX解析器 ​ SAX不用将整个文档加载到内存，基于事件驱动的API(Observer模式)，用户只需要注册自己感兴趣的事件即可。SAX提供EntityResolver, DTDHandler, ContentHandler, ErrorHandler接口，分别用于监听解析实体 事件、DTD处理事件、正文处理事件和处理出错事件，与AWT类似， SAX还提供了一个对这4个接口默认的类DefaultHandler（这里的默认实 现，其实就是一个空方法），一般只要继承DefaultHandler，重写自己感兴趣的事件即可。 JDOM解析器 ​ JDOM与DOM非常类似，它是处理XML的纯JAVA API，API大量使用了Collections类，且JDOM仅使用具体类而不使用接口。 JDOM 它自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML 文档 （尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档 DOM4J解析器 ​ DOM4J是目前在xml解析方面是最优秀的(Hibernate、Sun的 JAXM也都使用dom4j来解析XML)，它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理。 5 JDOM，DOM4J解析实例5.1 JDOM被解析的xml文件： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;database&gt; &lt;url&gt;jdbc:mysql://localhost:3306/studentinfo?characterEncoding=UTF-8&lt;/url&gt; &lt;user&gt;root&lt;/user&gt; &lt;pwd&gt;123123&lt;/pwd&gt; &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;&lt;/database&gt; JDOM解析： 1234567891011121314151617181920212223242526public class JDOM &#123; public static void main(String[] args) &#123; long lasting = System.currentTimeMillis(); try &#123; String path=DOM4Java.class.getClassLoader().getResource(&quot;&quot;) .toString().substring(6); SAXBuilder builder = new SAXBuilder(); Document doc = builder.build(new File(path+&quot;database.xml&quot;)); //获得xml文件的位置 Element foo = doc.getRootElement();//得到根节点 List allChildren = foo.getChildren(); for(int i=0;i&lt;allChildren.size();i++) &#123; //遍历子节点 System.out.println(((Element)allChildren.get(i)).getText()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;运行时间：&quot; + (System.currentTimeMillis() - lasting) + &quot;毫秒&quot;); &#125;&#125; 输出： 5.2 DOM4Jxml文件： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Result&gt; &lt;VALUE&gt; &lt;NO DATE=&quot;2005&quot;&gt;A1&lt;/NO&gt; &lt;ADDR&gt;GZ&lt;/ADDR&gt; &lt;/VALUE&gt; &lt;VALUE&gt; &lt;NO DATE=&quot;2004&quot;&gt;A2&lt;/NO&gt; &lt;ADDR&gt;XG&lt;/ADDR&gt; &lt;/VALUE&gt; &lt;note&gt; &lt;NO DATE=&quot;2014&quot;&gt;A4&lt;/NO&gt; &lt;ADDR&gt;XGgggg&lt;/ADDR&gt; &lt;/note&gt;&lt;/Result&gt; DOM4J: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DOM4Java &#123; public static void main(String[] args) &#123; long lasting = System.currentTimeMillis(); try &#123; String path=DOM4Java.class.getClassLoader().getResource(&quot;&quot;) .toString().substring(6);// 获得绝对路径 File f= new File(path+&quot;demo.xml&quot;); SAXReader reader = new SAXReader(); Document doc = reader.read(f); Element root = doc.getRootElement(); //得到根节点 System.out.println(root.getName()); Iterator it = root.elementIterator(&quot;VALUE&quot;);//迭代器，获取root下所有value 子标签 while(it.hasNext()) &#123; Element foo = (Element) it.next(); //得到value Element subfoo=foo.element(&quot;NO&quot;); //获取value 下NO 子标签 System.out.print(&quot;车牌号码:&quot; + foo.elementText(&quot;NO&quot;)+&quot; 属性：&quot; +subfoo.attributeValue(&quot;DATE&quot;)); System.out.println(&quot;车主地址:&quot; + foo.elementText(&quot;ADDR&quot;)); &#125; System.out.println(&quot;-----------------------------------&quot;); Element e=root.element(&quot;note&quot;); System.out.println(e.elementText(&quot;NO&quot;)); System.out.println(e.elementText(&quot;ADDR&quot;)); Element sube = e.element(&quot;NO&quot;); System.out.println(sube.attributeValue(&quot;DATE&quot;)); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;运行时间：&quot; + (System.currentTimeMillis() - lasting) + &quot;毫秒&quot;); &#125;&#125; 输出：","categories":[{"name":"XML","slug":"XML","permalink":"https://gigsider.com/categories/XML/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://gigsider.com/tags/XML/"}]},{"title":"计算机网络重点知识","slug":"Web-Points","date":"2019-12-11T07:24:45.000Z","updated":"2020-08-15T11:19:07.221Z","comments":true,"path":"blogs/Web-Points/","link":"","permalink":"https://gigsider.com/blogs/Web-Points/","excerpt":"","text":"​ 1 前言​ 计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。 ​ 计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP/IP标准网络协议。目前TCP/IP协议已经成为Internet中的”通用语言”，下图为不同计算机群之间利用TCP/IP进行通信的示意图。 2 网络层次划分​ 为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织(ISO)在1978年提出了”开放系统互联参考模型”，即著名的OSI/RM模型(Open System Interconnection/Reference Model)。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。 ​ 除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示： 3 OSI七层网络模型​ TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。 （1）物理层（Physical Layer） ​ 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 （2）数据链路层（Data Link Layer） ​ 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 有关数据链路层的重要知识点： 1&gt; 数据链路层为网络层提供可靠的数据传输； 2&gt; 基本数据单位为帧； 3&gt; 主要的协议：以太网协议； 4&gt; 两个重要设备名称：网桥和交换机。 （3）网络层（Network Layer） ​ 网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是”路径选择、路由及逻辑寻址“。 ​ 网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为： 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议： IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 4&gt; 重要的设备：路由器。 （4）传输层（Transport Layer） ​ 第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点： 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 3&gt; 重要设备：网关。 （5）会话层 ​ 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 （6）表示层 ​ 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 （7）应用层 ​ 为操作系统或网络应用程序提供访问网络服务的接口。 会话层、表示层和应用层重点： 1&gt; 数据传输基本单位为报文； 2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 4 IP地址（1）网络地址 ​ IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 （2）广播地址 ​ 广播地址通常称为直接广播地址，是为了区分受限广播地址。 ​ 广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 （3）组播地址 D类地址就是组播地址。 先回忆下A，B，C，D类地址吧： A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255； B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 （4）255.255.255.255 ​ 该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 ​ 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 （5）0.0.0.0 ​ 常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 （6）回环地址 ​ 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 （7）A、B、C类私有地址 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 5 ARP/RARP协议​ 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01； 主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02； ​ 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。 （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。 （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。 RARP协议工作流程： （1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； （2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； （3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用； （4）如果不存在，RARP服务器对此不做任何的响应； 6 路由选择协议常见的路由选择协议有：RIP协议、OSPF协议。 RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。 OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 7 TCP/IP协议​ TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 ​ IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。 ​ TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。 TCP运输连接的三个阶段： TCP协议的三次握手和四次挥手： ​ TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 ​ TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ ​ 为什么要三次握手？ ​ 在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，”三次握手”很有必要！ ​ 为什么要四次挥手？ ​ 试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！ ​ 使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。 8 UDP协议​ UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。 ​ UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。 ​ UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。 ​ 每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下： （1）源端口号； （2）目标端口号； （3）数据报长度； （4）校验值。 ​ 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 9 DNS协议​ DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 10 NAT协议​ NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 11 DHCP协议​ DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 12 HTTP协议​ 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？ GET：请求读取由URL所标志的信息。 POST：给服务器添加信息（如注释）。 PUT：在给定的URL下存储一个文档。 DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别 1）Get是从服务器上获取数据，Post是向服务器传送数据。 2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。 3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。 4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 13 一些细节13.1 拥塞控制和流量控制流量控制：如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。 ​ TCP的流量控制是利用滑动窗口机制实现的，接收方在返回的数据中会包含自己的接收窗口的大小，以控制发送方的数据发送。 拥塞控制：拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。 ​ 实现方法： 慢开始、拥塞避免、快重传和快恢复。发送端的发送数据量减少，路由器转发量增大。 ​ 两者的区别：流量控制是为了预防拥塞。如：在马路上行车，交警跟红绿灯是流量控制，当发生拥塞时，如何进行疏散，是拥塞控制。流量控制指点对点通信量的控制。而拥塞控制是全局性的，涉及到所有的主机和降低网络性能的因素。 13.2 粘包，拆包问题 发生原因 ​ 发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充， 1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。 2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。 3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去(采用Nagle算法，是TCP为了提高效率)，将会发生粘包。 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 等等。 解决办法 ​ 通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个： 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。 2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。 等等。 13.3 TCP如何保证可靠传输​ 超时重传，累加确认。 14 举例​ 在浏览器中输入 http://www.baidu.com/ 后执行的全部过程。 ​ 现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com， 而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作： 1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 15 参考资料http://www.cnblogs.com/maybe2030/p/4781555.html","categories":[{"name":"Web","slug":"Web","permalink":"https://gigsider.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://gigsider.com/tags/Web/"}]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/categories/Spring/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/categories/MarkDown/"},{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/categories/JAVA/"},{"name":"XML","slug":"XML","permalink":"https://gigsider.com/categories/XML/"},{"name":"Web","slug":"Web","permalink":"https://gigsider.com/categories/Web/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://gigsider.com/tags/AOP/"},{"name":"Spring","slug":"Spring","permalink":"https://gigsider.com/tags/Spring/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://gigsider.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://gigsider.com/tags/MarkDown/"},{"name":"JAVA","slug":"JAVA","permalink":"https://gigsider.com/tags/JAVA/"},{"name":"网络编程","slug":"网络编程","permalink":"https://gigsider.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"IO流","slug":"IO流","permalink":"https://gigsider.com/tags/IO%E6%B5%81/"},{"name":"XML","slug":"XML","permalink":"https://gigsider.com/tags/XML/"},{"name":"Web","slug":"Web","permalink":"https://gigsider.com/tags/Web/"}]}