<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析 GC 垃圾回收</title>
      <link href="/blogs/JVM-GC/"/>
      <url>/blogs/JVM-GC/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-GC-Roots"><a href="#1-GC-Roots" class="headerlink" title="1 GC Roots"></a>1 GC Roots</h1><p>GC Roots是一些由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ol><li>栈上的引用</li><li>本地方法栈上的引用</li><li>方法区上的引用</li></ol><h1 id="2-标记-清理"><a href="#2-标记-清理" class="headerlink" title="2 标记-清理"></a>2 标记-清理</h1><ol><li>标记阶段：用 GC Root 可达性算法找到所有可达的对象并将之标记<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927195055.png"></li><li>清除阶段：遍历堆中的所有对象，将没有被标记对象清除掉<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927195130.png"></li></ol><ul><li>缺点：容易产生内存碎片</li></ul><h1 id="3-标记-整理"><a href="#3-标记-整理" class="headerlink" title="3 标记-整理"></a>3 标记-整理</h1><ol><li>标记阶段：用 GC Root 可达性算法找到所有可达的对象并将之标记<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927195055.png"></li><li>整理阶段：将标记存活的对象移向内存的一端<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927195937.png"></li><li>清除阶段：从端边界开始清除<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927200004.png"></li></ol><ul><li>缺点：代价较大，效率较低</li></ul><h1 id="4-复制"><a href="#4-复制" class="headerlink" title="4 复制"></a>4 复制</h1><ol><li>按内存容量将内存划分为等大小的两块，该段时间内只允许在其中一块内存上进行分配</li><li>用 GC Root 可达性算法找到所有可达的对象并将之标记<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927200607.png"></li><li>将标记存活的对象复制到划分的另一块内存<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927200936.png"></li><li>直接清理当前块内存<br><br> <img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927201041.png"></li></ol><ul><li>缺点：可用内存被压缩到了原本的一半，且存活对象增多的话，复制算法的效率会大大降低</li></ul><h1 id="5-GC-分代回收"><a href="#5-GC-分代回收" class="headerlink" title="5 GC 分代回收"></a>5 GC 分代回收</h1><p>将堆区划分成年轻代（Young）和老年代（Old），对于年轻代再划分成 Eden（E），Survive0（S0）和Survive1（S1），大小比约为8:1:1。<br><br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927202025.png"></p><p>我们 new 的对象先是存在 Eden 区，当 Eden 区快满的时候会触发 Young GC，</p><ul><li>Young GC：采用的是复制法。S0 和 S1 交替工作，在 Eden 区的对象打完标记后，将标记存活的对象复制到 S0 区，然后将 Eden 区和 S1 区中的对象全部清除；等下次 Eden 区快满了之后，再将 S0 区和 Eden 区的对象打标记，将标记存活的对象复制到 S1 区，然后将 Eden 区和 S0 区中的对象全部清除。即：<ul><li>Eden + S1 复制到 S0</li><li>Eden + S0 复制到 S1</li><li>Eden + S1 复制到 S0</li><li>……如此往复</li></ul></li></ul><p>若一个对象在一次 Young GC 中存活了下来，则该对象的年龄加1，直到对象的年龄到达6，则直接将该对象放入 Old 区中。<br><br>Old 区中除了存一些年龄大于6的对象，还会存一些大对象（大对象不进行 Young 区的存储，直接存入 Old 区）。<br><br>Old 区快满的时候会执行 Old GC，Old GC 一般同时会伴随着 Young GC，所以又称为 Full GC，Full GC 会引起 stop the world，即整个 java 程序直接暂停，全力进行垃圾回收，主要采用标记清理或标记整理法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 内存模型</title>
      <link href="/blogs/JVM/"/>
      <url>/blogs/JVM/</url>
      
        <content type="html"><![CDATA[<p>JVM 内存主要分为5块：程序计数器、虚拟机栈、本地方法栈、堆、方法区。<br></p><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927145712.png"></p><h1 id="1-程序计数器（线程私有）"><a href="#1-程序计数器（线程私有）" class="headerlink" title="1 程序计数器（线程私有）"></a>1 程序计数器（线程私有）</h1><p>Program Counter Register，程序计数器就是在一些指令的执行过程中，记住下一条 jvm 指令的执行地址。物理上是通过寄存器来实现的。<br><br><br><br><strong>特点</strong></p><ul><li>线程私有的</li><li>不会存在内存溢出（JVM 规范所决定的）</li></ul><h1 id="2-虚拟机栈（线程私有）"><a href="#2-虚拟机栈（线程私有）" class="headerlink" title="2 虚拟机栈（线程私有）"></a>2 虚拟机栈（线程私有）</h1><p>-Xss 可用来配置栈内存大小，如：-Xss256k，可将栈内存设为256k<br><br><br>栈是线程私有的，一个栈有多个栈帧组成</p><ul><li>栈：可以理解为线程运行所需要的内存空间</li><li>栈帧：可以理解为线程中每个方法运行时所需要的内存（参数、局部变量、返回地址）</li><li>每个线程只能有一个活动栈帧，活动栈帧对应该线程正在执行的方法</li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200927152318.png"></p><ol><li>在一个线程中调用方法1时，会为方法1划分一段栈帧空间栈帧1，并将其压入栈中</li><li>方法1中调用了方法2，同理为方法2划分一段栈帧空间栈帧2，并将其压入栈中</li><li>方法2中调用方法3同理</li><li>方法执行结束后，对应的栈帧出栈</li></ol><h2 id="2-1-栈内存溢出"><a href="#2-1-栈内存溢出" class="headerlink" title="2.1 栈内存溢出"></a>2.1 栈内存溢出</h2><p>java.lang.StackOverflowError</p><ul><li>栈帧过多导致栈内存溢出</li><li>栈帧过大导致栈内存溢出</li></ul><h1 id="3-本地方法栈（线程私有）"><a href="#3-本地方法栈（线程私有）" class="headerlink" title="3 本地方法栈（线程私有）"></a>3 本地方法栈（线程私有）</h1><p>本地方法指那些不是由 java 代码编写的方法，因为 java 代码是有一定的限制的，它有的时候不能直接和操作系统底层打交道，所以就需要一些用 C/C++ 编写的本地方法，来与操作系统更底层的 API 打交道， java  代码可以通过本地方法来调用到底层的一些功能，这些本地方法运行时所使用的内存就是这个本地方法栈（Native Method Stacks）</p><h1 id="4-堆（线程共享）"><a href="#4-堆（线程共享）" class="headerlink" title="4 堆（线程共享）"></a>4 堆（线程共享）</h1><p>-Xmx 可用来配置堆内存大小，如：-Xmx8m，可将栈内存设为8m<br><br><br>通过 new 关键字创建对象都会使用堆内存。</p><p><strong>特点</strong></p><ul><li>线程共享的，堆中对象都要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h2 id="4-1-堆内存溢出"><a href="#4-1-堆内存溢出" class="headerlink" title="4.1 堆内存溢出"></a>4.1 堆内存溢出</h2><p>java.lang.OutOfMemoryError: Java heap space<br><br><br>对象被垃圾回收器回收的条件是这个对象没人在使用它了，但是，如果不断地产生对象且这些对象仍然有被使用，则这些对象不会被当成垃圾，当这些对象达到一定的数量就会导致堆内存的耗尽，及堆内存溢出。</p><h1 id="5-方法区（线程共享）"><a href="#5-方法区（线程共享）" class="headerlink" title="5 方法区（线程共享）"></a>5 方法区（线程共享）</h1><p>Method Area，方法区是所有 java 线程共享的一个区域，它存储了跟类的结构相关的一些信息（运行时常量池、成员变量、方法数据、成员方法和构造方法的代码部分）。<br><br>方法区在虚拟机启动时被创建，逻辑上是堆的组成部分，但不同 jvm 厂商的实现方式是不一样的。以 Hotspot 为例，在 jdk1.8 以前，方法区的实现叫做永久代，是堆内存的一部分。在 jdk1.8 以后，方法区的实现叫做元空间，元空间用的不再是堆的内存，而是本地内存（操作系统的内存）。<br><br>方法区如果申请内存时发现不足了，jvm 也会抛出 OutOfMemoryError。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC/DI</title>
      <link href="/blogs/Spring-IOC-DI/"/>
      <url>/blogs/Spring-IOC-DI/</url>
      
        <content type="html"><![CDATA[<p>Spring 是一个基于 IOC 和 AOP 结构，J2EE 系统的框架。IOC 反转控制是 Spring 的基础，Inversion Of Control 简单说就是创建对象由以前的程序员自己 new 构造方法来调用，变成了交由 Spring 容器创建对象；DI 依赖注入 Dependency Inject，简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。</p><a id="more"></a><h1 id="1-Spring-容器"><a href="#1-Spring-容器" class="headerlink" title="1 Spring 容器"></a>1 Spring 容器</h1><ul><li>在 Spring IOC 容器读取 Bean 配置创建 Bean 实例之前，必须对它进行实例化。只有在容器实例化后，才可以从 IOC 容器里获取 Bean 实例并使用。</li><li>Spring 提供了两种类型的 IOC 容器实现<ul><li>BeanFactory：IOC 容器的基本实现。</li><li>ApplicationContext：提供了更多的高级特性，是 BeanFactory 的子接口。</li><li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向 Spring 框架的使用者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory。</li><li>无论使用何种方式，配置文件时是同的。</li></ul></li><li>applicationContext.xml 是 Spring 的核心配置文件，通过关键字 category 即可获得 Category 对象，该对象获取的时候，即被注入了字符串”category 1”到 name 属性中。  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ff.po.Category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;category 1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2-IOC-和传统方式的区别"><a href="#2-IOC-和传统方式的区别" class="headerlink" title="2 IOC 和传统方式的区别"></a>2 IOC 和传统方式的区别</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200925214016.png"></p><ol><li>传统方式：通过 new 关键字主动创建一个对象</li><li>IOC 方式：对象的生命周期由 Spring 容器来管理，直接从 Spring 容器那里去获取一个对象。IOC 控制反转，就像是控制权从程序员的手中交给了 Spring。</li></ol><h2 id="2-1-注入对象的方式"><a href="#2-1-注入对象的方式" class="headerlink" title="2.1 注入对象的方式"></a>2.1 注入对象的方式</h2><ol><li>类中的 getter setter 方法</li><li>在 applicationContext.xml 中使用 ref 来注入另一个对象 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;product&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ff.po.Product&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;product 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3 常用注解"></a>3 常用注解</h1><ol><li>@Autowired，Spring的注解，默认按类型装配。如下，给这个测试类装配 Category 对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>@Resource，J2EE的注解，默认按名称装配。如下，作用和 @Autowired 一样，但是要加一个赋值(name=”category”)，不加的话默认按字段名查找 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Resource(name=&quot;category&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>@Component，用于标记一个类上，表示当前类是 Spring 的一个组件，会被实例化到 IOC 容器中，相当于配制文件中的 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;</code>，它有三个衍生注解（作用与 @Component 一模一样，只是为了让我们更好区分）：<ol><li>@Controller 用于标记在一个类上，代表这个类是控制层组件</li><li>@Service 用于标记在一个类上，代表这个类是业务层组件</li><li>@Repository 用于标记在一个类上，代表这个类是数据访问层组件</li></ol></li><li>@RequestMapping，是一个用来处理请求地址映射的注解，可用于类或方法上。用于类，表示类中所有响应请求的方法都是以该地址作为父路径。</li><li>@RequestParam，用于将指定的请求参数赋值给方法中的形参。</li><li>@PathVariable，可以获取 URL 中的动态参数。</li><li>@RequestBody，用于读取 Request 请求的 body 部分数据。</li><li>@ResponseBody，用于将 Controller 的方法返回的对象，用流响应给客户端。</li><li>@RestController=@Controller+@ResponseBody，用于标记在一个类上。</li><li>@Transactional，写在类上用于指定当前类中的方法支持事务，写在方法上表示当前方法支持事务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的 AOP 理解</title>
      <link href="/blogs/Java-AOP/"/>
      <url>/blogs/Java-AOP/</url>
      
        <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想。</p><a id="more"></a><h1 id="1-JDK-动态代理"><a href="#1-JDK-动态代理" class="headerlink" title="1 JDK 动态代理"></a>1 JDK 动态代理</h1><p>针对实现接口的类。<br><br>定义一个Proxy的子类，实现需要代理的类所实现的接口，在重写方法时插入切片。<br></p><h2 id="1-1-实例"><a href="#1-1-实例" class="headerlink" title="1.1 实例"></a>1.1 实例</h2><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200910220729.png"></p><blockquote><p>自定义接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现自定义接口的类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">IDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Demo method hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><blockquote><p>实现了InvocationHandler接口，DynDemo 是一个中间代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynDemo</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">// 此时 obj 是要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> BeforeMethod before;    <span class="comment">//切片, BeforeMethod 自行编写</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynDemo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 此时参数obj是要被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynDemo</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj = obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 此时参数obj是要被代理的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynDemo</span><span class="params">(Object obj,BeforeMethod before)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj = obj; </span><br><span class="line">        <span class="keyword">this</span>.before = before;</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这个方法不是我们显式的去调用  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="comment">//过滤不需要插入切片的方法，后期可通过读取配置文件来实现过滤</span></span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> method.invoke(obj, args);  <span class="comment">//真正的调用它原对象</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//如果切片不为空，则执行切片</span></span><br><span class="line">          <span class="keyword">if</span>(before != <span class="keyword">null</span>)</span><br><span class="line">               before.say();</span><br><span class="line"></span><br><span class="line">        Object result= method.invoke(obj, args);  <span class="comment">// 执行被代理对象的切入点，相当于obj.say(args);</span></span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>main 中测试使用动态代理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Demo target = <span class="keyword">new</span> Demo();<span class="comment">//这里指定被代理类  </span></span><br><span class="line">  </span><br><span class="line">    InvocationHandler ds=<span class="keyword">new</span> DynDemo(target, <span class="keyword">new</span> BeforeMethod() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Aspect test say&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; cls = target.getClass();<span class="comment">// 获取target对象类的字节码  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是一次性生成代理  </span></span><br><span class="line">    IDemo subject = (IDemo)Proxy.newProxyInstance(cls.getClassLoader(),cls.getInterfaces(), ds); </span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;\n\n&quot;</span>+<span class="string">&quot;未代理运行结果为：&quot;</span>);  </span><br><span class="line">    target.say();</span><br><span class="line">    target.hello();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;\n\n&quot;</span>+<span class="string">&quot;代理后运行结果为：&quot;</span>);  </span><br><span class="line">    subject.say();  </span><br><span class="line">    subject.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance()完成的功能：</p><ol><li>生成一个类$Proxy（Proxy的子类）</li><li>$Proxy 类会重写被代理类的接口。</li><li>每个方法调用中间代理类的invoke。</li></ol><blockquote><p>运行结果：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200911101441.png"></p><blockquote><p>自己模拟 Proxy.newProxyInstance 自动生成的类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于 Proxy 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MProxy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DynDemo target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MProxy</span><span class="params">(DynDemo target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于自动生成的 Proxy 的子类 $Proxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> <span class="keyword">extends</span> <span class="title">MProxy</span> <span class="keyword">implements</span> <span class="title">IDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxy</span><span class="params">(DynDemo target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         Method method=target.getObj().getClass().getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">           target.invoke(<span class="keyword">null</span>, method, <span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             Method method=target.getObj().getClass().getDeclaredMethod(<span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">               target.invoke(<span class="keyword">null</span>, method, <span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Throwable e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-CGLIB-字节码增强"><a href="#2-CGLIB-字节码增强" class="headerlink" title="2 CGLIB 字节码增强"></a>2 CGLIB 字节码增强</h1><p>针对未实现接口的类。<br><br>定义一个子类继承需要代理的类，重写父类的方法并插入切片。<br></p><h2 id="2-1-模拟实现"><a href="#2-1-模拟实现" class="headerlink" title="2.1 模拟实现"></a>2.1 模拟实现</h2><p>只是模拟实现原理，并非实际使用</p><blockquote><p>自定义 Demo 类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义 Demo 的子类 CGLDemo ，重写父类 Demo 方法以插入切片</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLDemo</span> <span class="keyword">extends</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    BeforeMethod before;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLDemo</span><span class="params">(BeforeMethod before)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.before != <span class="keyword">null</span>)</span><br><span class="line">            before.say();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main 中测试使用字节码增强进行代理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        CGLDemo cglDemo = <span class="keyword">new</span> CGLDemo(<span class="keyword">new</span> BeforeMethod() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Aspect before say&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n未代理运行结果：&quot;</span>);</span><br><span class="line">        demo.print();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n代理后运行结果：&quot;</span>);</span><br><span class="line">        cglDemo.print();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200911194553.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL]】索引</title>
      <link href="/blogs/MySQL-Index/"/>
      <url>/blogs/MySQL-Index/</url>
      
        <content type="html"><![CDATA[<p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的数据结构。索引的本质就是数据结构。</p><a id="more"></a><h1 id="1-索引的分类"><a href="#1-索引的分类" class="headerlink" title="1 索引的分类"></a>1 索引的分类</h1><ul><li>主键索引（Primary Key）<ul><li>唯一的标识，主键不可重复，只能有一个列作为主键</li></ul></li><li>唯一索引（Unique Key）<ul><li>避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引</li></ul></li><li>常规索引（Key/Index）<ul><li>默认的，index、key 关键字来设置</li></ul></li><li>全文索引（FullText）<ul><li>在特定的数据库引擎，MyISAM</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =============索引的使用=============</span></span><br><span class="line"><span class="comment">-- 1、可以在创建表的时候给字段增加索引</span></span><br><span class="line"><span class="comment">-- 2、也可以在表创建完后，再增加索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示所有的索引信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加一个全文索引  索引名（列名）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> fulltext <span class="keyword">index</span> <span class="string">`studentName`</span>(studentName);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- explain 分析 sql 执行的状况</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;  <span class="comment">-- 非全文索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">match</span>(studentName) against(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="2-索引原则"><a href="#2-索引原则" class="headerlink" title="2 索引原则"></a>2 索引原则</h1><ul><li>索引不是越多越好</li><li>不要对经常变动的数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上</li></ul><h1 id="3-索引的本质"><a href="#3-索引的本质" class="headerlink" title="3 索引的本质"></a>3 索引的本质</h1><ul><li>索引是帮助 MySQL 高效获取数据的排好序的数据结构</li><li>索引数据结构<ul><li>二叉树（单边增长的数据放入二叉树会会形成类似链表的结构，查找的性能没有提高）<br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200907161003.png"></li><li>红黑树（二叉平衡树，当数据量较大，树的深度较大，查询叶子节点时效率较低）<br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200907161156.png"></li><li>Hash（对范围查找的支持非常差）</li><li>B+Tree<ul><li>非叶子节点不存储data，只存储索引（冗余），可以放更多的索引</li><li>叶子节点包含所有索引字段</li><li>叶子节点用指针连接，提高区间访问的性能<br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200907161328.png"></li></ul></li></ul></li></ul><h2 id="3-1-MyISAM-存储引擎索引实现（非聚集）"><a href="#3-1-MyISAM-存储引擎索引实现（非聚集）" class="headerlink" title="3.1 MyISAM 存储引擎索引实现（非聚集）"></a>3.1 MyISAM 存储引擎索引实现（非聚集）</h2><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200907163942.png"></p><ul><li>非聚集索引，索引文件（.MYI）和数据文件（.MYD）是分离的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> Col1 = <span class="number">49</span>;</span><br><span class="line"><span class="comment">-- 首先判断Col1字段是否为索引字段</span></span><br><span class="line"><span class="comment">-- Col1 是索引字段， 去 .MYI 索引文件中快速检索定位，获取到 Col1=49 那一行的磁盘文件地址指针</span></span><br><span class="line"><span class="comment">-- 根据获取到的磁盘文件地址指针去 .MYD 文件中快速定位到 Col1=49 的那一行数据</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-InnoDB-存储引擎索引实现（聚集）"><a href="#3-2-InnoDB-存储引擎索引实现（聚集）" class="headerlink" title="3.2 InnoDB 存储引擎索引实现（聚集）"></a>3.2 InnoDB 存储引擎索引实现（聚集）</h2><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200908092906.png"></p><ul><li>表数据文件（.ibd 文件）本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引，叶子节点包含了完整的数据记录，索引和数据聚集在一个文件（.ibd）中</li></ul><blockquote><p>参考资料:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL]】事务</title>
      <link href="/blogs/MySQL-Transaction/"/>
      <url>/blogs/MySQL-Transaction/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1 什么是事务"></a>1 什么是事务</h1><p>事务(Transaction)为了实现某一目的而进行的一系列操作，<br>要么都成功，要么都失败。</p><h1 id="2-ACID原则"><a href="#2-ACID原则" class="headerlink" title="2 ACID原则"></a>2 ACID原则</h1><ul><li><strong>原子性（Atomicity）</strong><br><br>  原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：A(800) 向 B(200) 转账200</span><br><span class="line">A: 800 - 200 &#x3D; 600</span><br><span class="line">B: 200 + 200 &#x3D; 400</span><br><span class="line">原子性要求步骤 A 和步骤 B 要一起成功或者一起失败，不能只发生其中一个动作。</span><br></pre></td></tr></table></figure></li><li><strong>一致性（Consistency）</strong><br><br>  事务前后数据的完整性必须保持一致。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：A(800) 向 B(200) 转账200</span><br><span class="line">A: 800 - 200 &#x3D; 600</span><br><span class="line">B: 200 + 200 &#x3D; 400</span><br><span class="line">转账事务开始前，A 和 B 的账户总额为1000，一致性要求转账事务结束后A 和 B 的账户总额不变，仍为1000。</span><br></pre></td></tr></table></figure></li><li><strong>隔离性（Isolation）</strong><br><br>  事务的隔离性是指多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其它事务的操作所干扰，多个并发事务之间要相互隔离。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">事务1：A 给 B 转账200</span><br><span class="line">事务2：C 给 B 转账100</span><br><span class="line">隔离性要求事务1和事务2不会相互影响。</span><br></pre></td></tr></table></figure></li><li><strong>持久性（Durablity）</strong><br><br>  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例：例：A(800) 向 B(200) 转账200</span><br><span class="line">执行前： A 800， B 200</span><br><span class="line">执行后： A 600， B 400</span><br><span class="line"></span><br><span class="line">如果在事务提交前，服务器宕机或断电，那么重启数据库后，数据状态应为：</span><br><span class="line">A 800， B 200</span><br><span class="line"></span><br><span class="line">如果在事务提交后，服务器宕机或断电，那么重启数据库后，数据状态应为：</span><br><span class="line">A 600， B 400</span><br></pre></td></tr></table></figure><h1 id="3-脏读、幻读、不可重复读"><a href="#3-脏读、幻读、不可重复读" class="headerlink" title="3 脏读、幻读、不可重复读"></a>3 脏读、幻读、不可重复读</h1></li><li><strong>脏读</strong><br><br>  所谓脏读是指一个事务中访问到了另外一个事务未提交的数据，如下图：<table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td></td><td></td></tr><tr><td>select age from table where id=1</td><td></td></tr><tr><td>commit</td><td>commit</td></tr><tr><td>如果会话 2 更新 age 为 10，但是在 commit 之前，会话 1 希望得到 age，那么会获得的值就是更新前的值。或者如果会话 2 更新了值但是执行了 rollback，而会话 1 拿到的仍是 10。这就是脏读。</td><td></td></tr></tbody></table></li><li><strong>幻读</strong><br><br>  一个事务读取2次，得到的记录条数不一致：<table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select age from table where id&gt;2</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>select age from table where id&gt;2</td><td></td></tr><tr><td>commit</td><td></td></tr><tr><td>由于在会话 1 之间插入了一个新的值，所以得到的两次数据就不一样了。</td><td></td></tr></tbody></table></li><li><strong>不可重复读</strong><br><br>  一个事务读取同一条记录2次，得到的结果不一致：<br>  一个事务读取同一条记录2次，得到的结果不一致：<table><thead><tr><th>会话1</th><th>会话2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select age from table where id=1</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>select age from table where id=1</td><td></td></tr><tr><td>commit</td><td></td></tr><tr><td>由于在读取中间变更了数据，所以会话 1 事务查询期间的得到的结果就不一样了。</td><td></td></tr></tbody></table></li></ul><h1 id="4-数据隔离级别"><a href="#4-数据隔离级别" class="headerlink" title="4 数据隔离级别"></a>4 数据隔离级别</h1><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(Read Uncommitted)</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交(Read Committed)</td><td>x</td><td>√</td><td>√</td></tr><tr><td>可重复读(Repeatable Read)</td><td>x</td><td>x</td><td>√</td></tr><tr><td>串行化(Serializable)</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><ul><li><strong>读未提交</strong><br><br>  允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。</li><li><strong>读已提交</strong><br><br>  允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</li><li><strong>可重复读</strong><br><br>  禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。</li><li><strong>序列化</strong><br><br>  提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</li></ul><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p><h1 id="5-sql-事务操作"><a href="#5-sql-事务操作" class="headerlink" title="5 sql 事务操作"></a>5 sql 事务操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- =============事务=============</span></span><br><span class="line"><span class="comment">-- MySQL 是默认开启事务并自动提交的</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span> <span class="comment">/* 关闭 */</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">1</span> <span class="comment">/* 开启（默认） */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 手动处理事务</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span> <span class="comment">-- 关闭自动提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务开启</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> <span class="comment">-- 标记一个事务的开始，从这个之后的 sql 都在同一个事务内</span></span><br><span class="line"></span><br><span class="line">...... <span class="comment">-- 事务中的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交：持久化（执行成功）</span></span><br><span class="line"><span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚：回到原来的样子（执行失败）</span></span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务结束</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">1</span> <span class="comment">-- 开启自动提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其它</span></span><br><span class="line"><span class="keyword">savepoint</span> 保存点名 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> 保存点名 <span class="comment">-- 回滚到保存点</span></span><br><span class="line"><span class="keyword">release</span> <span class="keyword">savepoint</span> 保存点名 <span class="comment">-- 撤销保存点</span></span><br></pre></td></tr></table></figure><blockquote><p>参考资料:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL]】数据查询</title>
      <link href="/blogs/MySQL-Query/"/>
      <url>/blogs/MySQL-Query/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-select-语法"><a href="#1-select-语法" class="headerlink" title="1 select 语法"></a>1 select 语法</h2><p>上下先后顺序很重要</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">all</span> | <span class="keyword">distinct</span>]</span><br><span class="line">&#123;* | table.* | [table.field1[<span class="keyword">as</span> alias1][,table.field2[<span class="keyword">as</span> alias2]][,...]]&#125;</span><br><span class="line"><span class="keyword">from</span> table_name [<span class="keyword">as</span> table_alias]</span><br><span class="line">    [<span class="keyword">left</span> | <span class="keyword">right</span> | <span class="keyword">inner</span> <span class="keyword">join</span> table_name2]    <span class="comment">-- 联表查询</span></span><br><span class="line">    [<span class="keyword">where</span> ...] <span class="comment">-- 指定结果满足的条件</span></span><br><span class="line">    [<span class="keyword">group</span> <span class="keyword">by</span> ..]   <span class="comment">-- 制定结果按照哪几个字段来分组</span></span><br><span class="line">    [<span class="keyword">having</span> ...]    <span class="comment">-- 过滤分组的记录必须满足的条件</span></span><br><span class="line">    [<span class="keyword">order</span> <span class="keyword">by</span> ...]  <span class="comment">-- 指定查询记录按一个或多个条件排序</span></span><br><span class="line">    [<span class="keyword">limit</span> &#123;[<span class="keyword">offset</span>,]<span class="keyword">row_count</span> | row_countOFFSET <span class="keyword">offset</span>&#125;];   <span class="comment">-- 指定查询的记录从哪条至哪条</span></span><br></pre></td></tr></table></figure><h2 id="2-where-条件子句"><a href="#2-where-条件子句" class="headerlink" title="2 where 条件子句"></a>2 where 条件子句</h2><p>作用：检索数据中符合条件的值。<br><br>搜索条件由一个或多个条件组成，返回结果为布尔值。</p><h3 id="2-1-逻辑运算符"><a href="#2-1-逻辑运算符" class="headerlink" title="2.1 逻辑运算符"></a>2.1 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>and (&amp;&amp;)</td><td>a and b (a&amp;&amp;b)</td><td>逻辑与</td></tr><tr><td>or (||)</td><td>a or b (a||b)</td><td>逻辑或</td></tr><tr><td>not (!)</td><td>not a (!a)</td><td>逻辑非</td></tr></tbody></table><h2 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3 模糊查询"></a>3 模糊查询</h2><p>比较运算符：<br>运算符 | 语法 | 描述<br>—|—|—<br>is null | a is null| 如果操作符为null，结果为真<br>is not null | a is not null | 如果操作符不为null，结果为真<br>between | a between b and c | 若a在b和c之间，结果为真<br>like | a like b | SQL匹配，若a匹配b，结果为真<br>in | a in(a1,a2,a3…) | 若a为(a1,a2…)中的任意一值，结果为真</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ============== like ===============</span></span><br><span class="line"><span class="comment">-- like 结合 %（表示任意个字符），_（表示一个字符）</span></span><br><span class="line"><span class="comment">-- 查询所有姓刘的同学</span></span><br><span class="line"><span class="keyword">select</span> stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuName <span class="keyword">like</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询名字为两个字姓刘的同学</span></span><br><span class="line"><span class="keyword">select</span> stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuName <span class="keyword">like</span> <span class="string">&#x27;刘_&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询名字中有 佳 字的同学</span></span><br><span class="line"><span class="keyword">select</span> stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuName <span class="keyword">like</span> <span class="string">&#x27;%佳%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ============== in ===============</span></span><br><span class="line"><span class="comment">-- 查询学号为1,3,5,7,9的学生</span></span><br><span class="line"><span class="keyword">select</span> stuId, stuName <span class="keyword">from</span> student <span class="keyword">where</span> stuId <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- ============== null,not null ===============</span></span><br><span class="line"><span class="comment">-- 查询地址为空的学生</span></span><br><span class="line"><span class="keyword">select</span> stuId, stuName <span class="keyword">from</span> student <span class="keyword">where</span> address=<span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> address <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询出生日期不为空的学生</span></span><br><span class="line"><span class="keyword">select</span> stuId, stuName <span class="keyword">from</span> student <span class="keyword">where</span> birth <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="4-联表查询"><a href="#4-联表查询" class="headerlink" title="4 联表查询"></a>4 联表查询</h2><h3 id="4-1-七种-join-理论（图源百度）"><a href="#4-1-七种-join-理论（图源百度）" class="headerlink" title="4.1 七种 join 理论（图源百度）"></a>4.1 七种 join 理论（图源百度）</h3><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200821094046.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* student(stuId,stuName)</span></span><br><span class="line"><span class="comment">* exam(stuId,courseId,score)</span></span><br><span class="line"><span class="comment">* 查询所有参加了考试的学生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- join on 连接查询</span></span><br><span class="line"><span class="comment">-- where   等值查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- inner join</span></span><br><span class="line"><span class="keyword">select</span> s.stuId, stuName, courseId, score</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> exam <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">on</span> s.stuId = e.stuId;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- right join</span></span><br><span class="line"><span class="keyword">select</span> s.stuId, stuName, courseId, score</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> exam <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">on</span> s.stuId = e.stuId;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- left join</span></span><br><span class="line"><span class="keyword">select</span> s.stuId, stuName, courseId, score</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> exam <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">on</span> s.stuId = e.stuId;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>inner join</td><td>如果表中至少有一个匹配，就返回值</td></tr><tr><td>left join</td><td>即使右表中没有匹配，也会从左表中返回所有的值</td></tr><tr><td>right join</td><td>即使左表中没有匹配，也会从右表中返回所有的值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* student(stuId,stuName)</span></span><br><span class="line"><span class="comment">* exam(stuId,courseId,score)</span></span><br><span class="line"><span class="comment">* course(courseId,courseName)</span></span><br><span class="line"><span class="comment">* 查询所有参加了考试的学生的学号、姓名、课程名、分数信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> s.stuId, stuName, courseName, score</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> exam e</span><br><span class="line"><span class="keyword">on</span> s.stuId = e.stuId</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> course c</span><br><span class="line"><span class="keyword">on</span> e.courseId = c.courseId;</span><br></pre></td></tr></table></figure><h2 id="5-常用聚合函数"><a href="#5-常用聚合函数" class="headerlink" title="5 常用聚合函数"></a>5 常用聚合函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>计数</td></tr><tr><td>SUM()</td><td>求和</td></tr><tr><td>AVG()</td><td>平均值</td></tr><tr><td>MAX()</td><td>最大值</td></tr><tr><td>MIN()</td><td>最小值</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 都能够统计表中的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="string">`stuId`</span>) <span class="keyword">from</span> student; <span class="comment">-- count(字段)，会忽略所有的 null 值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> student;   <span class="comment">-- count(*)，包含了所有列，不会忽略 null 值，本质计算行数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student;   <span class="comment">-- count(1)，忽略了所有列，用1代表代码行，不会忽略 null 值</span></span><br></pre></td></tr></table></figure><blockquote><p>参考资料:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MySQL]】删除语句 Delete 和 Truncate</title>
      <link href="/blogs/MySQL-Delete-Truncate/"/>
      <url>/blogs/MySQL-Delete-Truncate/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Delete"><a href="#1-Delete" class="headerlink" title="1 Delete"></a>1 Delete</h2><p>语法：<code>delete from 表名 [where 条件]</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表中的全部数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`student`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表中的指定数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`student`</span> <span class="keyword">where</span> stuId = <span class="number">1</span>; </span><br></pre></td></tr></table></figure><h2 id="2-Truncate"><a href="#2-Truncate" class="headerlink" title="2 Truncate"></a>2 Truncate</h2><p>作用：完全清空一个数据库表，表的结构和索引约束不会变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清空 student 表</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> <span class="string">`student`</span>;</span><br></pre></td></tr></table></figure><h2 id="3-Delete-和-Truncate-的区别"><a href="#3-Delete-和-Truncate-的区别" class="headerlink" title="3 Delete 和 Truncate 的区别"></a>3 Delete 和 Truncate 的区别</h2><ul><li>相同点：都能删除数据，都不会删除表结构。</li><li>不同点：<ul><li>Truncate 重新设置自增列，计数器会清零</li><li>Truncate 不会影响事务<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 测试 delete 和 truncate 的区别</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test`</span>(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="string">`coll`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test`</span>(<span class="string">`coll`</span>) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>),(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`test`</span>  <span class="comment">-- 不会影响自增计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> <span class="string">`test`</span>   <span class="comment">-- 自增计数器归零</span></span><br></pre></td></tr></table></figure></li></ul></li><li>delete 删除重启数据库的现象：<ul><li>InnoDB 自增列会从1开始（存储在内存中的，断电即失）</li><li>MyISAM 继续从上一个自增量开始（存在文件中的，不会丢失）</li></ul></li></ul><blockquote><p>参考资料:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 MySQL 数据库</title>
      <link href="/blogs/Database-MySQL/"/>
      <url>/blogs/Database-MySQL/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-初始MySQL"><a href="#1-初始MySQL" class="headerlink" title="1 初始MySQL"></a>1 初始MySQL</h2><p>JavaEE：企业级JavaWeb开发</p><p>前端：页面展示</p><p>后端：连接数据库，连接前端</p><p>数据库：存储管理数据</p><h3 id="1-1-什么是数据库"><a href="#1-1-什么是数据库" class="headerlink" title="1.1 什么是数据库"></a>1.1 什么是数据库</h3><p>数据库（DB，DataBase）</p><p>概念：数据仓库，软件，安装在操作系统之上，可以存储大量的数据。</p><p>作用：存储数据、管理数据。</p><h3 id="1-2-数据库分类"><a href="#1-2-数据库分类" class="headerlink" title="1.2 数据库分类"></a>1.2 数据库分类</h3><p>关系型数据库（SQL）：</p><ul><li>MySQL，Oracle，SQLServer，Sqlite…</li><li>通过表和表之间，行和列之间的关系进行数据的存储。</li></ul><p>非关系型数据库（NoSQL）：</p><ul><li>Redis，MongoDB …</li><li>对象存储，通过对象自身的属性来决定。</li></ul><p>DBMS（数据库管理系统）</p><ul><li>数据库的管理软件，科学有效的管理我们的数据，维护和获取数据。</li></ul><h3 id="1-3-MySQL简介"><a href="#1-3-MySQL简介" class="headerlink" title="1.3 MySQL简介"></a>1.3 MySQL简介</h3><p>MySQL是一个关系型数据库管理系统。是最好的RDBMS开源应用软件之一。体积小、速度快。适用于中小型网站，或大型网站（集群）。</p><h2 id="2-MySQL-数据库"><a href="#2-MySQL-数据库" class="headerlink" title="2 MySQL 数据库"></a>2 MySQL 数据库</h2><h3 id="2-1-数据库的列类型"><a href="#2-1-数据库的列类型" class="headerlink" title="2.1 数据库的列类型"></a>2.1 数据库的列类型</h3><blockquote><p>数值</p></blockquote><ul><li>tinyint   十分小的数据    1个字节</li><li>smallint  较小的数据  2个字节</li><li>mediumint 中等大小的数据  3个字节</li><li>int   标准的整数  4个字节（常用的）</li><li>bigint    较大的数据  8个字节</li><li>float     浮点数      4个字节</li><li>double    浮点数      8个字节</li><li>decimal   字符串形式的浮点数  金融计算的时候常用（float，double有精度问题）</li></ul><blockquote><p>字符串</p></blockquote><ul><li>char  固定大小的字符串    0-255</li><li>varchar   可变字符串  0-65535（常用的变量）</li><li>tinytext  微型文本    2^8-1</li><li>text      文本串      2^16-1（保存大文本）</li></ul><blockquote><p>时间日期</p></blockquote><ul><li>date YYYY-MM-DD   日期</li><li>time  HH:mm:ss    时间格式</li><li>datetime  YYYY-MM-DD HH:mm:ss 最常用的时间格式</li><li>timestamp 时间戳  1970.1.1到现在的毫秒数，较为常用</li><li>year  年份表示</li></ul><blockquote><p>null</p></blockquote><ul><li>没有值，未知</li></ul><h3 id="2-2-数据库的字段属性"><a href="#2-2-数据库的字段属性" class="headerlink" title="2.2 数据库的字段属性"></a>2.2 数据库的字段属性</h3><p>==unsigned==：</p><ul><li>无符号的整数</li><li>声明了该列不能为负数</li></ul><p>==zerofill==：</p><ul><li>0填充的</li><li>不足的位数，使用0来填充，例：int(3), 1-&gt;001</li></ul><p>==autoincreament==：</p><ul><li>通常理解为自增，自动在上一条记录的基础上加1</li><li>通常用来设计唯一的主键，必须是整数类型</li><li>可以自定义设计自增的起始值和步长</li></ul><p>==not null==：</p><ul><li>非空</li><li>假设设置为 not null ，如果不给它赋值，就会报错</li><li>如果不填值，默认就是 null</li></ul><p>==default==：</p><ul><li>设置默认的值</li></ul><h3 id="2-3-数据表的类型"><a href="#2-3-数据表的类型" class="headerlink" title="2.3 数据表的类型"></a>2.3 数据表的类型</h3><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较小</td><td>较大，约为 MYISAM 的2倍</td></tr></tbody></table><p>常规使用操作：</p><ul><li>MYISAM    节约空间，速度较快</li><li>INNODB    安全性高，事务的处理，多表多用户操作</li></ul><p>在物理空间存在的位置：</p><p>所有的数据库文件都存在 data 目录下，一个文件夹久对应一个数据库，本质还是文件的存储。</p><p>MySQL 引擎在物理文件上的区别</p><ul><li>InnoDB 在数据表中只有 *.frm 文件，以及上级目录下的 ibdata1 文件。</li><li>MyISAM 对应的文件<ul><li>*.frm 表结构的定义文件</li><li>*.MYD 数据文件（data）</li><li>*.MYI 索引文件（index）</li></ul></li></ul><p>设置数据表的字符集编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure><p>不设置的话，会是 MySQL 默认的字符集编码Latin1（不支持中文）</p><blockquote><p>参考资料:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 5.7 免安装版</title>
      <link href="/blogs/MySQL-5.7/"/>
      <url>/blogs/MySQL-5.7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1 软件下载"></a>1 软件下载</h2><p>下载地址：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><p>下载mysql 5.7… ZIP免安装版本</p><h2 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2 操作步骤"></a>2 操作步骤</h2><ol><li>下载后得到zip压缩包</li><li>解压到自己想要安装到的目录</li><li>添加环境变量<ol><li>右击此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</li><li>选择 PATH ，在其后添加你的 MySQL 文件夹下 bin 文件夹的路径</li><li>在 MySQL 文件夹下新建 my.ini 文件</li><li>编辑 my.ini 文件（注意替换路径位置）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># MySQL 文件夹路径</span><br><span class="line">basedir&#x3D;..:\..\mysql..\</span><br><span class="line"># MySQL 文件夹下 data 文件夹路径（data 文件夹没有不要自己新建，之后会自动生成）</span><br><span class="line">datadir&#x3D;..:\..\mysql..\data\</span><br><span class="line"># MySQL 运行端口，默认为3306</span><br><span class="line">port&#x3D;3306</span><br><span class="line"># 跳过密码验证，修改好密码后需注释掉</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></li><li>以管理员身份启动命令提示符（CMD），cd 进入 MySQL 下的 bin 目录， 然后输入 <code>mysqld -install</code> （安装mysql）</li><li>输入 <code>mysqld --initialize-insecure --user=mysql</code> 初始化数据文件（此步骤会自动生成上述 data 目录）</li><li>输入 <code>net start mysql</code> 启动 mysql</li><li>通过命令行进入 mysql ，<code>mysql -u root -p</code> （-p 后面不能加空格），出现“Enter password:”直接按回车</li><li>进入 mysql 页面后输入 <code>update mysql.user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; and Host=&#39;localhost&#39;;</code> 将 root 用户密码更改为123456</li><li>在 mysql 页面中输入 <code>flush privileges</code> 刷新权限</li><li>修改 my.ini 文件注释掉最后一句skip-grant-tables</li><li>在 mysql 页面下输入<code>exit</code>退出 mysql 页面，在命令行中输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure>重启 mysql 即可正常使用。</li></ol></li></ol><blockquote><p>资料来源:<a href="https://space.bilibili.com/95256449">https://space.bilibili.com/95256449</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 协议</title>
      <link href="/blogs/TCP/"/>
      <url>/blogs/TCP/</url>
      
        <content type="html"><![CDATA[<p>TCP（Transmission Control Protocol）：<br><br>面向连接的，可靠的，基于字节流的传输层通信协议</p><a id="more"></a><h1 id="1-特点"><a href="#1-特点" class="headerlink" title="1 特点"></a>1 特点</h1><ul><li>基于连接的：数据传输之前需要建立连接</li><li>全双工的：双向传输</li><li>字节流：不限制数据大小，打包成报文段，保证有序接收，重复报文自动丢弃</li><li>流量缓冲：解决双方处理能力的不匹配</li><li>可靠的传输服务：保证可达，丢包时通过重发机制实现可靠性</li><li>拥塞控制：防止网络出现恶性拥塞</li></ul><h1 id="2-UDP-和-TCP-的对比"><a href="#2-UDP-和-TCP-的对比" class="headerlink" title="2 UDP 和 TCP 的对比"></a>2 UDP 和 TCP 的对比</h1><table><thead><tr><th>UDP（User Datagram Protocol）</th><th>TCP（Transmission Control Protocol）</th></tr></thead><tbody><tr><td>无连接</td><td>面向连接</td></tr><tr><td>支持一对一，一对多，多对一和多对多交互通信</td><td>每一条 TCP 连接只能有两个端点，只能是一对一通信</td></tr><tr><td>对应用层交付的报文直接打包</td><td>面向字节流</td></tr><tr><td>尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr></tbody></table><p>TCP协议适用于对效率要求相对低，但对准确性要求相对高的场景，如文件传输、邮件接收等；而UDP协议适用于对效率要求相对高，对准确性要求相对低的场景，如在线直播、在线会议等。</p><h1 id="3-TCP-报文"><a href="#3-TCP-报文" class="headerlink" title="3 TCP 报文"></a>3 TCP 报文</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200924190057.png"></p><h1 id="4-三次握手"><a href="#4-三次握手" class="headerlink" title="4 三次握手"></a>4 三次握手</h1><ol><li>TCP 连接：四元组（源地址，源端口，目的地址，目的端口）</li><li>确立连接：TCP 三次握手<ol><li>同步通信双方初识序列号（ISN，initial sequence number）</li><li>协商 TCP 通信参数（MSS，窗口信息，指定校验和算法）</li></ol></li></ol><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200924211821.png"></p><h1 id="5-四次挥手"><a href="#5-四次挥手" class="headerlink" title="5 四次挥手"></a>5 四次挥手</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200924215746.png"></p><p>A：发送 FIN 数据报，代表 A 不再发送数据<br><br>B：收到请求，发送 ACK 应答，避免了 A 重新发送 FIN 数据报（应答机制）<br><br>B：处理完数据之后关闭连接，即发送 FIN 请求<br><br>A：收到请求后发送 ACK 应答，B 服务可以释放连接<br><br><br><br>A：等待 2MSL 后释放连接</p><ol><li>防止报文丢失，导致 B 重复发送 FIN</li><li>防止滞留在网络中的报文对新建立的连接造成数据干扰</li></ol><blockquote><p>参考资料：<a href="https://space.bilibili.com/472427006">https://space.bilibili.com/472427006</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 协议 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP 模型</title>
      <link href="/blogs/TCP-IP/"/>
      <url>/blogs/TCP-IP/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200911204445.png"></p><h1 id="1-协议"><a href="#1-协议" class="headerlink" title="1 协议"></a>1 协议</h1><p>协议是一种约定，计算机之间想要传递信息需要双方约定好数据的格式。网络协即是一个共同的标准，大家都来遵守，两台计算机的通信需要协议和标准的数据格式才能进行。<h1 id="2-协议分层"><a href="#2-协议分层" class="headerlink" title="2 协议分层"></a>2 协议分层</h1><p>协议分层的最大好处就是便于封装。<h2 id="2-1-OSI-七层模型"><a href="#2-1-OSI-七层模型" class="headerlink" title="2.1 OSI 七层模型"></a>2.1 OSI 七层模型</h2><p>OSI（Open System Interconnection Reference Model）：开放系统互联参考模型<ol><li>物理层：界定连接器和网线之间的规格</li><li>数据链路层：互联设备之间传送和识别数据帧</li><li>网络层：地址管理和路由选择</li><li>传输层：管理两个节点之间的数据传递。负责可靠传输</li><li>会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层</li><li>表示层：设备固定的数据格式和网络标准数据格式之间的转化</li><li>应用层：针对你特定应用的协议</li></ol><p>OSI 七层模型最大的优点就是将服务、接口和协议三个概念明确的区分起来，缺点则是复杂且不实用；经常使用的是 TCP/IP 五（四）层模型。<h2 id="2-2-TCP-IP-五（四）层模型"><a href="#2-2-TCP-IP-五（四）层模型" class="headerlink" title="2.2 TCP/IP 五（四）层模型"></a>2.2 TCP/IP 五（四）层模型</h2><p>每一层都呼叫它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层称为网际接口层）<ol><li>物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。</li><li>数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。</li><li>网络层：负责地址管理和路由选择。路由器工作在网络层。</li><li>传输层：负责两台主机之间的数据传输。</li><li>应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。</li></ol><p>传输层和网络层的封装在操作系统完成。应用层的封装在应用程序中完成。数据链路层和物理层的封装在设备驱动程序与网络接口中完成。<ul><li>对于一台主机，它的操作系统内核实现了传输层到物理层的内容。</li><li>对于一台路由器，它实现了从网络层到物理层。</li><li>对于一台交换机，它实现了由数据链路层到物理层。</li><li>对于集线器，他只实现了物理层。</li></ul><h1 id="3-一个-HTTP-请求的分层解析流程"><a href="#3-一个-HTTP-请求的分层解析流程" class="headerlink" title="3 一个 HTTP 请求的分层解析流程"></a>3 一个 HTTP 请求的分层解析流程</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200913210709.png"></p><ol><li>浏览器中输入域名：gigsiderfun.com</li><li>客户端查看缓存和本地 host 文件中是否存在此域名对应的 ip 地址，有的话则转到步骤6，否则继续</li><li>客户端发起一个 DNS 请求<ol><li>应用层构造一个 DNS 请求报文，往下交给传输层</li><li>传输层在 DNS 报文的基础上加上 UDP 的请求头，往下交给网络层</li><li>网络层在 UDP 的请求报文基础上加上 IP 的请求头，往下交给数据链路层</li><li>数据链路层会将自己的 MAC 地址以及对应的请求报文应该要交给下一个机器的 MAC 地址加上去，往下交给物理层</li><li>物理层通过物理介质将请求传出去</li></ol></li><li>DNS 服务器接收到请求查找到 gigsiderfun.com 对应的 ip 地址，发起一个 DNS 响应报文原路返回</li><li>客户端收到 DNS 响应报文进行层层解析，得到 gigsiderfun.com 对应的 ip 地址</li><li>客户端发起一个 HTTP 请求<ol><li>应用层构造一个 HTTP 请求报文，往下交给传输层</li><li>传输层在 HTTP 报文的基础上加上 TCP 的请求头，往下交给网络层</li><li>网络层在 TCP 的请求报文基础上加上 IP 的请求头，往下交给数据链路层</li><li>数据链路层会将自己的 MAC 地址以及对应的请求报文应该要交给下一个机器的 MAC 地址加上去，往下交给物理层</li><li>物理层通过物理介质将请求传出去</li></ol></li><li>对应服务器接收到 HTTP 请求对 HTTP 请求报文进行层层解析<ol><li>物理层接收到 HTTP 请求报文向上交给数据链路层</li><li>数据链路层通过 MAC 地址检查该报文是不是给自己的，是的话就进行解析并向上交给网络层</li><li>网络层通过 IP 地址检查是不是给自己的，是的话就进行解析并向上交给传输层</li><li>传输层解析 TCP 的端口并将请求报文交给应用程序</li><li>应用程序拿到了对应的 HTTP 请求报文并进行解析</li></ol></li><li>服务器解析完成后构造并发起一个 HTTP 响应报文</li><li>客户端接收到 HTTP 响应报文进行层层解析获取到网页资源并展示在浏览器上</li></ol><blockquote><p>参考资料：<a href="https://blog.csdn.net/ffsiwei/article/details/82121010">https://blog.csdn.net/ffsiwei/article/details/82121010</a><br>            <br><a href="https://space.bilibili.com/472427006">https://space.bilibili.com/472427006</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 协议</title>
      <link href="/blogs/HTTPS/"/>
      <url>/blogs/HTTPS/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="1-HTTPS"><a href="#1-HTTPS" class="headerlink" title="1 HTTPS"></a>1 HTTPS</h1><p>由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能在链路中截获、修改或者伪造请求/响应报文，数据不具有可信性。因此就诞生了为安全而生的 HTTPS 协议。<br><br>使用 HTTPS 时，所有的 HTTP 请求和响应在发送到网络之前，都要进行加密。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200925100611.png"></p><h1 id="2-摘要算法"><a href="#2-摘要算法" class="headerlink" title="2 摘要算法"></a>2 摘要算法</h1><p>摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。任意微小的数据差异，都可以生成完全不同的摘要。所以可以通过把明文信息的摘要和明文一起加密进行传输，数据传输到对方后再进行解密，重新对数据进行摘要，再比对就能发现数据有没有被篡改。这样就保证了数据的完整性。<br><br>目前常用的摘要算法：MD5、SHA-1、SHA-256</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200925102307.png"></p><h1 id="3-加密算法"><a href="#3-加密算法" class="headerlink" title="3 加密算法"></a>3 加密算法</h1><h2 id="3-1-对称密钥加密算法"><a href="#3-1-对称密钥加密算法" class="headerlink" title="3.1 对称密钥加密算法"></a>3.1 对称密钥加密算法</h2><p>编、解码使用相同密钥的算法，如AES、RC4、ChaCha20。<br><br>使用异或(xor)实现的对称加密：<br><br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200925103737.png"></p><h2 id="3-2-非对称密钥加密算法"><a href="#3-2-非对称密钥加密算法" class="headerlink" title="3.2 非对称密钥加密算法"></a>3.2 非对称密钥加密算法</h2><p>它有两个密钥，一个叫“公钥”，一个叫“私钥”。两个密钥是不同的，公钥可以公开给任何人使用，而私钥必须严格保密。非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意发布公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。非对称秘钥加密系统通常需要大量的数学运算，效率较低。常用非对称密钥加密算法有 DH、DSA、RSA、ECC。<br><br><br><br>TLS 里使用的混合加密方式，即把对称加密和非对称加密结合起来，两者互相取长补短，既能高效的加密解密，又能安全的密钥交换。大致流程如下：</p><ol><li>通信开始的时候使用非对称加密算法如 RSA 先解决密钥交换的问题。</li><li>用随机数产生对称算法使用的“会话密钥”，再用公钥加密。会话密钥很短，所以即便使用非对称加密算法也可以很快完成加解密。</li><li>对方拿到密文后使用私钥解密，取出会话密钥，完成对称密钥的安全交换，后续就使用对称算法完成数据交换。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200925152139.png"></p><blockquote><p>参考资料：<a href="https://space.bilibili.com/472427006">https://space.bilibili.com/472427006</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 协议 </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议</title>
      <link href="/blogs/HTTP/"/>
      <url>/blogs/HTTP/</url>
      
        <content type="html"><![CDATA[<p>HTTP（HyperText Transfer Protocol），超文本传输协议<br><br>HTTP 协议是一种无状态的、以请求/应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统（HTML）灵活的互动。</p><a id="more"></a><h1 id="1-HTTP-报文格式"><a href="#1-HTTP-报文格式" class="headerlink" title="1 HTTP 报文格式"></a>1 HTTP 报文格式</h1><p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p><ul><li>起始行（start line）：描述请求或响应的基本信息</li><li>头部字段集合（header）：使用 key-value 形式更详细的说明报文</li><li>消息正文（entity）：实际传输的数据，它不一定是文本，可以是图片、视频等二进制数据<br><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200923205319.png"></li></ul><h1 id="2-请求行报文格式"><a href="#2-请求行报文格式" class="headerlink" title="2 请求行报文格式"></a>2 请求行报文格式</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200923210146.png"></p><ul><li>请求方法：如 GET/HEAD/PUT/POST，表示对资源的操作</li><li>请求目标：通常是一个 URI，标记了请求方法要操作的资源</li><li>版本号：表示报文使用的 HTTP 协议版本</li></ul><h1 id="3-响应行报文格式"><a href="#3-响应行报文格式" class="headerlink" title="3 响应行报文格式"></a>3 响应行报文格式</h1><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200923210244.png"></p><ul><li>版本号：表示报文使用的 HTTP 协议版本</li><li>状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误</li><li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因</li></ul><h1 id="4-HTTP-头字段"><a href="#4-HTTP-头字段" class="headerlink" title="4 HTTP 头字段"></a>4 HTTP 头字段</h1><p>头部字段是 key-value 的形式， key 和 value 之间用冒号”:”分隔，最后用 CRLF 换行表示字段结束。比如前后端分离时常遇到的要与后端协商传输数据的类型”Content-type:application/json”，这里 key 就是 Content-type，value 就是 application/json。HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p><h2 id="4-1-头字段注意事项"><a href="#4-1-头字段注意事项" class="headerlink" title="4.1 头字段注意事项"></a>4.1 头字段注意事项</h2><ul><li>字段名不区分大小写，字段名里不允许出现空格，可以使用连字符”-“，但不能使用下划线”_”（有的服务器不会解析带下划线的头字段）。字段名后面必须紧跟着”:”，不能有空格，而”:”后的字段值可以有多个空格</li><li>字段的顺序是没有意义的，可以任意排列不影响语义</li><li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie</li></ul><h2 id="4-2-常用头字段"><a href="#4-2-常用头字段" class="headerlink" title="4.2 常用头字段"></a>4.2 常用头字段</h2><p>HTTP 协议中有非常多的头字段，但基本上可以分为四大类：</p><ul><li>请求字段：请求中的头字段；如 Host，Referer。</li><li>相应字段：响应中的头字段；如：Server。</li><li>通用字段：在请求和响应中都可以出现；如 Content-type，Connection。</li></ul><h1 id="5-HTTP-请求的完整过程"><a href="#5-HTTP-请求的完整过程" class="headerlink" title="5 HTTP 请求的完整过程"></a>5 HTTP 请求的完整过程</h1><p>当用户在浏览器中输入网址按回车后，网络协议做了以下工作：</p><ol><li>首先干活的是浏览器应用程序，它要解析 URL 中的域名</li><li>根据域名获取对应的 ip 地址，首先从浏览器缓存中查看，如果没有，则从本机域名解析文件 hosts 中查看，还没有则从 LDNS（LocalDNSServer）、RootServer 域名服务器、国际顶级域名服务商的 DNS 服务器中查找</li><li>拿到 ip 地址后，浏览器就可以发起与服务器的三次握手</li><li>握手建立后，就开始组装 http 请求报文，发送报文</li><li>服务器收到请求报文后开始解析请求报文，生成响应数据，组装成响应报文，发送响应报文</li><li>浏览器收到响应后，开始渲染页面</li></ol><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200923214347.png"></p><blockquote><p>参考资料：<a href="https://space.bilibili.com/472427006">https://space.bilibili.com/472427006</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 协议 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown 基础语法</title>
      <link href="/blogs/MarkDown-First-Met/"/>
      <url>/blogs/MarkDown-First-Met/</url>
      
        <content type="html"><![CDATA[<p>MarkDown 是一种轻量级标记语言。Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。</p><a id="more"></a><hr><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1 标题"></a>1 标题</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题名</span><br><span class="line">## 二级标题名</span><br><span class="line">### 三级标题名</span><br><span class="line">......</span><br><span class="line">###### 六级标题名</span><br></pre></td></tr></table></figure><p>标题最多支持六级标题</p><h2 id="2-文字"><a href="#2-文字" class="headerlink" title="2 文字"></a>2 文字</h2><hr><p>有些文字格式 MarkDown 的原生语法并不包括，</p><p>解决方案：</p><ul><li><a href="#2-5-%E4%B8%8B%E5%88%92%E7%BA%BF">使用HTML的标签</a></li><li><a href="#2-5-%E4%B8%8B%E5%88%92%E7%BA%BF">使用HTML标签+CSS样式实现自己想要的字体格式</a></li></ul><h3 id="2-1-删除线"><a href="#2-1-删除线" class="headerlink" title="2.1 删除线"></a>2.1 删除线</h3><p>使用”~~”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~加上删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果：<del>加上删除线的文字</del></p><h3 id="2-2-斜体"><a href="#2-2-斜体" class="headerlink" title="2.2 斜体"></a>2.2 斜体</h3><p>使用”*”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*斜体的文字*</span><br></pre></td></tr></table></figure><p>效果：<em>斜体的文字</em></p><h3 id="2-3-加粗"><a href="#2-3-加粗" class="headerlink" title="2.3 加粗"></a>2.3 加粗</h3><p>使用”**”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加粗的文字**</span><br></pre></td></tr></table></figure><p>效果：<strong>加粗的文字</strong></p><h3 id="2-4-表格"><a href="#2-4-表格" class="headerlink" title="2.4 表格"></a>2.4 表格</h3><p>使用”|”来分隔不同的单元格，使用”-“来分隔表头和其他行，为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用”|”来标记单元格边界，在表头下方的分隔线标记中加入”:”，即可标记下方单元格内容的对齐方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|    Name    |    Age    |    Sex    |</span><br><span class="line">| :--------- | :-------: | --------: |</span><br><span class="line">| Ming       | 19        | Male      |</span><br><span class="line">| Hong       | 20        | Female    |</span><br><span class="line">| Gang       | 18        | Male      |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">Name</th><th align="center">Age</th><th align="right">Sex</th></tr></thead><tbody><tr><td align="left">Ming</td><td align="center">19</td><td align="right">Male</td></tr><tr><td align="left">Hong</td><td align="center">20</td><td align="right">Female</td></tr><tr><td align="left">Gang</td><td align="center">18</td><td align="right">Male</td></tr></tbody></table><h3 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h3><p>使用 HTML <code>&lt;u&gt;</code> 标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;HTML u 标签&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure><p>使用 HTML 标签 + CSS 样式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;border-bottom:2px dashed yellow;&quot;&gt;HTML 标签 + CSS 样式&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>u标签效果：<u>HTML u 标签</u></p><p>HTML + CSS 效果: <span style="border-bottom:2px dashed yellow;">HTML 标签 + CSS 样式</span></p><h3 id="2-6-上标、下标"><a href="#2-6-上标、下标" class="headerlink" title="2.6 上标、下标"></a>2.6 上标、下标</h3><p>上标使用 HTML <code>&lt;sup&gt;</code> 标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUPER&lt;sup&gt;我是上标&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure><p>下标使用 HTML <code>&lt;sub&gt;</code> 标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB&lt;sub&gt;我是下标&lt;&#x2F;sub&gt;</span><br></pre></td></tr></table></figure><p>上标效果：SUPER<sup>我是上标</sup></p><p>下标效果：SUB<sub>我是下标</sub></p><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h2><hr><p>使用”&gt;”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;朝辞白帝彩云间</span><br><span class="line">&gt;&gt;千里江陵一日还</span><br><span class="line">&gt;&gt;&gt;两岸猿声啼不住</span><br><span class="line">&gt;&gt;&gt;&gt;轻舟已过万重山</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>朝辞白帝彩云间</p><blockquote><p>千里江陵一日还</p><blockquote><p>两岸猿声啼不住</p><blockquote><p>轻舟已过万重山</p></blockquote></blockquote></blockquote></blockquote><h2 id="4-列表"><a href="#4-列表" class="headerlink" title="4 列表"></a>4 列表</h2><hr><h3 id="4-1-有序列表"><a href="#4-1-有序列表" class="headerlink" title="4.1 有序列表"></a>4.1 有序列表</h3><p>使用”数字. “:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 注意&quot;.&quot;后要有空格</span><br><span class="line">2. 列表</span><br><span class="line">3. 有序列表</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>注意”.”后要有空格</li><li>列表</li><li>有序列表</li></ol><h3 id="4-2-无序列表"><a href="#4-2-无序列表" class="headerlink" title="4.2 无序列表"></a>4.2 无序列表</h3><p>使用”*”或”+”或”-“:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 注意符号后要有空格</span><br><span class="line">+ 列表</span><br><span class="line">- 无序列表</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>注意符号后要有空格</li></ul><ul><li>列表</li></ul><ul><li>无序列表</li></ul><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><hr><p>代码中的文本都会显示为原始内容。</p><h3 id="5-1-代码块"><a href="#5-1-代码块" class="headerlink" title="5.1 代码块"></a>5.1 代码块</h3><p>使用”```语言名称”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;c++</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-行内代码"><a href="#5-2-行内代码" class="headerlink" title="5.2 行内代码"></a>5.2 行内代码</h3><p>使用”<code>``</code>“:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;System.out.println(&quot;Hello world!&quot;)&#96;</span><br></pre></td></tr></table></figure><p>效果：<code>System.out.println(&quot;Hello world!&quot;)</code></p><h2 id="6-分割线"><a href="#6-分割线" class="headerlink" title="6 分割线"></a>6 分割线</h2><hr><p>使用”—“或”___”或”***”（符号数大于三个即可）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">******</span><br><span class="line">----------</span><br><span class="line">_____</span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><h2 id="7-跳转"><a href="#7-跳转" class="headerlink" title="7 跳转"></a>7 跳转</h2><hr><p>使用”<code>[现实的文本](跳转的链接)</code>“:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我的博客](https:&#x2F;&#x2F;www.gigsider-fun.com)</span><br></pre></td></tr></table></figure><p>使用”&lt;跳转的链接&gt;”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.gigsider-fun.com&gt;</span><br></pre></td></tr></table></figure><p><code>[]()</code>效果：<a href="https://www.gigsider-fun.com/">我的博客</a></p><p><code>&lt;&gt;</code>效果：<a href="https://www.gigsider-fun.com/">https://www.gigsider-fun.com</a></p><h2 id="8-图片"><a href="#8-图片" class="headerlink" title="8 图片"></a>8 图片</h2><hr><p>使用”<code>![图片的描述](图片的地址)</code>“:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![测试图片](MarkDown-First-Met&#x2F;test.png)</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.gigsider.com/qiniu/20200812213441.png" alt="markdown"></p><hr><blockquote><p>资料来源：<a href="https://space.bilibili.com/32157804">https://space.bilibili.com/32157804</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
